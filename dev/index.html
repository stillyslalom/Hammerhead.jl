<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Hammerhead.jl</title><meta name="title" content="Home · Hammerhead.jl"/><meta property="og:title" content="Home · Hammerhead.jl"/><meta property="twitter:title" content="Home · Hammerhead.jl"/><meta name="description" content="Documentation for Hammerhead.jl."/><meta property="og:description" content="Documentation for Hammerhead.jl."/><meta property="twitter:description" content="Documentation for Hammerhead.jl."/><meta property="og:url" content="https://stillyslalom.github.io/Hammerhead.jl/"/><meta property="twitter:url" content="https://stillyslalom.github.io/Hammerhead.jl/"/><link rel="canonical" href="https://stillyslalom.github.io/Hammerhead.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Hammerhead.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Key-Features"><span>Key Features</span></a></li><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Core-Data-Structures"><span>Core Data Structures</span></a></li><li><a class="tocitem" href="#Windowing-Functions"><span>Windowing Functions</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/stillyslalom/Hammerhead.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/stillyslalom/Hammerhead.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hammerhead.jl"><a class="docs-heading-anchor" href="#Hammerhead.jl">Hammerhead.jl</a><a id="Hammerhead.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Hammerhead.jl" title="Permalink"></a></h1><p>A modern, high-performance Julia package for Particle Image Velocimetry (PIV) analysis, designed to provide capabilities on par with established tools while leveraging Julia&#39;s performance and ecosystem.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Hammerhead.jl provides a complete PIV analysis pipeline for experimental fluid dynamics applications. The package processes image pairs to extract velocity vector fields, supporting both simple single-stage analysis and sophisticated multi-stage processing for improved accuracy in challenging flow conditions.</p><h2 id="Key-Features"><a class="docs-heading-anchor" href="#Key-Features">Key Features</a><a id="Key-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Features" title="Permalink"></a></h2><ul><li><strong>High Performance</strong>: Type-stable implementations with optimized FFT-based correlation</li><li><strong>Flexible Configuration</strong>: Multi-stage processing with configurable window sizes, overlap ratios, and windowing functions</li><li><strong>Quality Assessment</strong>: Built-in peak ratio and correlation moment metrics for vector validation</li><li><strong>Modern Architecture</strong>: Clean APIs with property forwarding and symbol-based configuration</li><li><strong>Comprehensive Windowing</strong>: Support for all DSP.jl windowing functions (Hanning, Hamming, Blackman, Kaiser, etc.)</li><li><strong>Robust Processing</strong>: Boundary handling with symmetric padding and graceful error recovery</li></ul><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><h3 id="Basic-PIV-Analysis"><a class="docs-heading-anchor" href="#Basic-PIV-Analysis">Basic PIV Analysis</a><a id="Basic-PIV-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-PIV-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Hammerhead

# Load your image pair
img1 = load(&quot;image1.tif&quot;)
img2 = load(&quot;image2.tif&quot;)

# Perform single-stage PIV analysis
result = run_piv(img1, img2, window_size=(64, 64), overlap=(0.5, 0.5))

# Access results with clean API
displacement_x = result.u  # X-direction displacements
displacement_y = result.v  # Y-direction displacements
positions_x = result.x     # Grid x-coordinates
positions_y = result.y     # Grid y-coordinates
quality = result.peak_ratio # Quality metrics</code></pre><h3 id="Multi-Stage-Processing"><a class="docs-heading-anchor" href="#Multi-Stage-Processing">Multi-Stage Processing</a><a id="Multi-Stage-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Stage-Processing" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create multi-stage configuration for improved accuracy
stages = PIVStages(3, 32,  # 3 stages ending at 32×32 windows
                   overlap=0.5,
                   window_function=:hanning)

# Perform multi-stage analysis
results = run_piv(img1, img2, stages)

# Access final stage results
final_result = results[end]</code></pre><h3 id="Advanced-Configuration"><a class="docs-heading-anchor" href="#Advanced-Configuration">Advanced Configuration</a><a id="Advanced-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Custom stage configuration with different parameters
stage1 = PIVStage((128, 128), overlap=(0.75, 0.75), window_function=:rectangular)
stage2 = PIVStage((64, 64), overlap=(0.5, 0.5), window_function=:hanning)
stage3 = PIVStage((32, 32), overlap=(0.25, 0.25), window_function=(:kaiser, 5.0))

results = run_piv(img1, img2, [stage1, stage2, stage3])</code></pre><h3 id="Performance-Timing"><a class="docs-heading-anchor" href="#Performance-Timing">Performance Timing</a><a id="Performance-Timing-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Timing" title="Permalink"></a></h3><p>Hammerhead.jl automatically instruments all PIV operations with detailed timing data:</p><pre><code class="language-julia hljs"># Run PIV analysis (timing is automatic)
result = run_piv(img1, img2, window_size=(64, 64))

# Access timing information
using TimerOutputs  # Need to import for print_timer
timer = get_timer(result)
print_timer(timer)  # Prints detailed timing breakdown

# For multi-stage analysis, timing is in the first result
results = run_piv(img1, img2, stages)
timer = get_timer(results[1])</code></pre><p>Timing data includes hierarchical breakdown of:</p><ul><li>FFT operations (forward, inverse, setup)</li><li>Cross-correlation computation  </li><li>Peak analysis and subpixel refinement</li><li>Window processing and padding</li><li>Grid generation and result assembly</li></ul><h2 id="Core-Data-Structures"><a class="docs-heading-anchor" href="#Core-Data-Structures">Core Data Structures</a><a id="Core-Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Data-Structures" title="Permalink"></a></h2><h3 id="PIVVector"><a class="docs-heading-anchor" href="#PIVVector">PIVVector</a><a id="PIVVector-1"></a><a class="docs-heading-anchor-permalink" href="#PIVVector" title="Permalink"></a></h3><p>Individual vector measurement containing position, displacement, and quality metrics.</p><h3 id="PIVResult"><a class="docs-heading-anchor" href="#PIVResult">PIVResult</a><a id="PIVResult-1"></a><a class="docs-heading-anchor-permalink" href="#PIVResult" title="Permalink"></a></h3><p>Container for complete analysis results with property forwarding for ergonomic access:</p><ul><li><code>result.x</code>, <code>result.y</code> - Grid positions</li><li><code>result.u</code>, <code>result.v</code> - Displacement components  </li><li><code>result.peak_ratio</code> - Primary/secondary peak ratio</li><li><code>result.correlation_moment</code> - Correlation peak sharpness</li></ul><h3 id="PIVStage"><a class="docs-heading-anchor" href="#PIVStage">PIVStage</a><a id="PIVStage-1"></a><a class="docs-heading-anchor-permalink" href="#PIVStage" title="Permalink"></a></h3><p>Configuration for individual processing stages with type-safe parameters:</p><ul><li>Window size and overlap ratios</li><li>Windowing functions (rectangular, Hanning, Hamming, Blackman, Kaiser, etc.)</li><li>Interpolation methods</li><li>Deformation iterations</li></ul><h2 id="Windowing-Functions"><a class="docs-heading-anchor" href="#Windowing-Functions">Windowing Functions</a><a id="Windowing-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Windowing-Functions" title="Permalink"></a></h2><p>Hammerhead.jl leverages DSP.jl for mathematically correct windowing functions:</p><pre><code class="language-julia hljs"># Simple windows
PIVStage((64, 64), window_function=:hanning)
PIVStage((64, 64), window_function=:blackman)

# Parametric windows  
PIVStage((64, 64), window_function=(:kaiser, 5.0))
PIVStage((64, 64), window_function=(:tukey, 0.3))</code></pre><p>Supported functions include: <code>:rectangular</code>, <code>:hanning</code>, <code>:hamming</code>, <code>:blackman</code>, <code>:bartlett</code>, <code>:cosine</code>, <code>:lanczos</code>, <code>:triang</code>, <code>:kaiser</code>, <code>:tukey</code>, <code>:gaussian</code>.</p><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><ul><li>Optimized for large image processing with fast correlation algorithms</li><li>Memory efficient processing of extensive datasets </li><li>Type-stable implementations throughout for optimal performance</li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;Hammerhead&quot;)</code></pre><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><ul><li><a href="#Hammerhead.PIVResult"><code>Hammerhead.PIVResult</code></a></li><li><a href="#Hammerhead.PIVStage"><code>Hammerhead.PIVStage</code></a></li><li><a href="#Hammerhead.PIVVector"><code>Hammerhead.PIVVector</code></a></li><li><a href="#Hammerhead.PIVStages-Tuple{Int64, Int64}"><code>Hammerhead.PIVStages</code></a></li><li><a href="#Hammerhead.analyze_correlation_plane-Tuple{AbstractMatrix}"><code>Hammerhead.analyze_correlation_plane</code></a></li><li><a href="#Hammerhead.apply_image_deformation-Tuple{AbstractMatrix{&lt;:Real}, PIVResult, Tuple{Int64, Int64}}"><code>Hammerhead.apply_image_deformation</code></a></li><li><a href="#Hammerhead.apply_window_function-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Hammerhead.WindowFunction}} where T"><code>Hammerhead.apply_window_function</code></a></li><li><a href="#Hammerhead.barycentric_coordinates-NTuple{4, AbstractVector}"><code>Hammerhead.barycentric_coordinates</code></a></li><li><a href="#Hammerhead.bilinear_interpolate-Tuple{AbstractMatrix{&lt;:Real}, Float64, Float64}"><code>Hammerhead.bilinear_interpolate</code></a></li><li><a href="#Hammerhead.calculate_correlation_moment-Tuple{AbstractMatrix, CartesianIndex}"><code>Hammerhead.calculate_correlation_moment</code></a></li><li><a href="#Hammerhead.calculate_quality_metrics-Tuple{AbstractMatrix, CartesianIndex, Real}"><code>Hammerhead.calculate_quality_metrics</code></a></li><li><a href="#Hammerhead.compute_convergence_metric-Tuple{PIVResult, PIVResult}"><code>Hammerhead.compute_convergence_metric</code></a></li><li><a href="#Hammerhead.compute_local_affine_transform-Tuple{Float64, Float64, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Tuple{Int64, Int64}}"><code>Hammerhead.compute_local_affine_transform</code></a></li><li><a href="#Hammerhead.fill_symmetric_padding!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64, Int64, Tuple{Int64, Int64}}} where T"><code>Hammerhead.fill_symmetric_padding!</code></a></li><li><a href="#Hammerhead.find_containing_triangle-Tuple{AbstractMatrix, Real, Real}"><code>Hammerhead.find_containing_triangle</code></a></li><li><a href="#Hammerhead.find_local_maxima-Tuple{AbstractMatrix}"><code>Hammerhead.find_local_maxima</code></a></li><li><a href="#Hammerhead.find_secondary_peak-Tuple{AbstractMatrix, CartesianIndex, Real}"><code>Hammerhead.find_secondary_peak</code></a></li><li><a href="#Hammerhead.find_secondary_peak_robust-Tuple{AbstractMatrix, CartesianIndex, Real}"><code>Hammerhead.find_secondary_peak_robust</code></a></li><li><a href="#Hammerhead.generate_interrogation_grid-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}}"><code>Hammerhead.generate_interrogation_grid</code></a></li><li><a href="#Hammerhead.generate_window_1d-Tuple{Hammerhead.SimpleWindow, Int64}"><code>Hammerhead.generate_window_1d</code></a></li><li><a href="#Hammerhead.get_timer-Tuple{PIVResult}"><code>Hammerhead.get_timer</code></a></li><li><a href="#Hammerhead.interpolate_vectors-Tuple{PIVResult}"><code>Hammerhead.interpolate_vectors</code></a></li><li><a href="#Hammerhead.is_area_preserving"><code>Hammerhead.is_area_preserving</code></a></li><li><a href="#Hammerhead.linear_barycentric_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}"><code>Hammerhead.linear_barycentric_interpolation</code></a></li><li><a href="#Hammerhead.linear_interpolation_2points-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, Symbol}"><code>Hammerhead.linear_interpolation_2points</code></a></li><li><a href="#Hammerhead.nearest_neighbor_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}"><code>Hammerhead.nearest_neighbor_interpolation</code></a></li><li><a href="#Hammerhead.pad_to_size-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Int64, Int64}}} where T"><code>Hammerhead.pad_to_size</code></a></li><li><a href="#Hammerhead.run_iterative_deformation-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, PIVStage, PIVResult, TimerOutputs.TimerOutput}"><code>Hammerhead.run_iterative_deformation</code></a></li><li><a href="#Hammerhead.run_piv-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>Hammerhead.run_piv</code></a></li><li><a href="#Hammerhead.run_piv_stage-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, PIVStage, Any, TimerOutputs.TimerOutput}"><code>Hammerhead.run_piv_stage</code></a></li><li><a href="#Hammerhead.validate_affine_transform-Tuple{AbstractMatrix}"><code>Hammerhead.validate_affine_transform</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.PIVResult" href="#Hammerhead.PIVResult"><code>Hammerhead.PIVResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PIVResult</code></pre><p>Container for complete PIV analysis results with property forwarding.</p><p><strong>Fields</strong></p><ul><li><code>vectors::StructArray{PIVVector}</code> - Vector field data</li><li><code>metadata::Dict{String, Any}</code> - Processing parameters and run information  </li><li><code>auxiliary::Dict{String, Any}</code> - Additional data (correlation planes, secondary peaks, etc.)</li></ul><p><strong>Property Forwarding</strong></p><p>Provides direct access to vector field properties:</p><ul><li><code>result.x</code> → <code>result.vectors.x</code></li><li><code>result.u</code> → <code>result.vectors.u</code></li><li>etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L76-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.PIVStage" href="#Hammerhead.PIVStage"><code>Hammerhead.PIVStage</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PIVStage{W&lt;:WindowFunction, I&lt;:InterpolationMethod}</code></pre><p>Configuration for individual processing stage in multi-stage PIV analysis.</p><p><strong>Fields</strong></p><ul><li><code>window_size::Tuple{Int, Int}</code> - Window dimensions (height, width)</li><li><code>overlap::Tuple{Float64, Float64}</code> - Overlap ratios (vertical, horizontal) ∈ [0, 1)</li><li><code>padding::Int</code> - Window padding pixels</li><li><code>deformation_iterations::Int</code> - Number of deformation iterations</li><li><code>window_function::W</code> - Windowing function type</li><li><code>interpolation_method::I</code> - Interpolation method type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L251-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.PIVVector" href="#Hammerhead.PIVVector"><code>Hammerhead.PIVVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PIVVector</code></pre><p>Individual vector data point containing position, displacement, and quality metrics.</p><p><strong>Fields</strong></p><ul><li><code>x::Float64</code> - Grid x-coordinate</li><li><code>y::Float64</code> - Grid y-coordinate  </li><li><code>u::Float64</code> - Displacement in x-direction</li><li><code>v::Float64</code> - Displacement in y-direction</li><li><code>status::Symbol</code> - Vector status (<code>:good</code>, <code>:interpolated</code>, <code>:bad</code>, <code>:secondary</code>)</li><li><code>peak_ratio::Float64</code> - Primary/secondary peak ratio</li><li><code>correlation_moment::Float64</code> - Correlation peak sharpness metric</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L40-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.PIVStages-Tuple{Int64, Int64}" href="#Hammerhead.PIVStages-Tuple{Int64, Int64}"><code>Hammerhead.PIVStages</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PIVStages(n_stages::Int, final_size::Int; kwargs...) -&gt; Vector{PIVStage}</code></pre><p>Create a vector of PIVStage configurations for multi-stage PIV analysis with geometric window size progression.</p><p><strong>Arguments</strong></p><ul><li><code>n_stages::Int</code> - Number of processing stages</li><li><code>final_size::Int</code> - Final window size (smallest stage)</li></ul><p><strong>Keyword Arguments</strong></p><p>All PIVStage parameters are supported with either scalar or vector values:</p><ul><li><code>overlap=0.5</code> - Overlap ratio(s). Can be scalar, tuple, or vector of scalars/tuples</li><li><code>padding=0</code> - Padding pixel(s). Can be scalar or vector</li><li><code>deformation_iterations=3</code> - Deformation iteration(s). Can be scalar or vector  </li><li><code>window_function=:rectangular</code> - Window function(s). Can be symbol, tuple (symbol, params...), or vector thereof</li><li><code>interpolation_method=:bilinear</code> - Interpolation method(s). Can be scalar symbol or vector of symbols</li></ul><p><strong>Parameter Handling</strong></p><ul><li><strong>Scalar values</strong>: Applied to all stages</li><li><strong>Vector values</strong>: Must have length 1 (applied to all) or length <code>n_stages</code> (one per stage)</li><li><strong>Overlap</strong>: Scalar values create symmetric overlap <code>(val, val)</code>, tuples are used directly</li></ul><p><strong>Window Size Progression</strong></p><p>Stages use geometric progression: <code>final_size * 2^(n_stages - i)</code> for stage <code>i</code>,  with minimum size constrained to <code>final_size</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic usage with scalar parameters
stages = PIVStages(3, 32, overlap=0.5, window_function=:hanning)

# Mixed scalar and vector parameters  
stages = PIVStages(3, 32, overlap=[0.75, 0.5, 0.25], padding=5)

# Different window functions per stage
stages = PIVStages(2, 32, window_function=[:rectangular, :hanning])

# Parametric window functions
stages = PIVStages(3, 32, window_function=[(:kaiser, 5.0), :hanning, (:tukey, 0.3)])

# Asymmetric overlap
stages = PIVStages(2, 32, overlap=(0.6, 0.4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L301-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.analyze_correlation_plane-Tuple{AbstractMatrix}" href="#Hammerhead.analyze_correlation_plane-Tuple{AbstractMatrix}"><code>Hammerhead.analyze_correlation_plane</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyze_correlation_plane(correlation_plane) -&gt; (displacement, peak_ratio, correlation_moment)</code></pre><p>Analyze correlation plane to extract displacement and quality metrics at PIV stage level. This allows the same analysis to be applied to results from different correlation algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L724-L729">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.apply_image_deformation-Tuple{AbstractMatrix{&lt;:Real}, PIVResult, Tuple{Int64, Int64}}" href="#Hammerhead.apply_image_deformation-Tuple{AbstractMatrix{&lt;:Real}, PIVResult, Tuple{Int64, Int64}}"><code>Hammerhead.apply_image_deformation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_image_deformation(img, displacement_field, window_size) -&gt; deformed_image</code></pre><p>Apply smooth deformation to an image based on a PIV displacement field.</p><p>Uses local affine transforms computed from displacement field to deform the image. Each pixel&#39;s new location is computed by interpolating local transform parameters.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray{&lt;:Real,2}</code> - Input image to deform</li><li><code>displacement_field::PIVResult</code> - PIV result containing displacement vectors  </li><li><code>window_size::Tuple{Int,Int}</code> - Window size for local transform computation</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{&lt;:Real,2}</code> - Deformed image with same size as input</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1675-L1690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.apply_window_function-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Hammerhead.WindowFunction}} where T" href="#Hammerhead.apply_window_function-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Hammerhead.WindowFunction}} where T"><code>Hammerhead.apply_window_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_window_function(subimage, window_function) -&gt; windowed_subimage</code></pre><p>Apply windowing function to subimage to reduce spectral leakage in correlation analysis. Uses DSP.jl implementations for mathematically correct and well-tested window functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.barycentric_coordinates-NTuple{4, AbstractVector}" href="#Hammerhead.barycentric_coordinates-NTuple{4, AbstractVector}"><code>Hammerhead.barycentric_coordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">barycentric_coordinates(p1, p2, p3, query)</code></pre><p>Compute barycentric coordinates of query point with respect to triangle p1-p2-p3.</p><p>Returns (λ1, λ2, λ3) such that query = λ1<em>p1 + λ2</em>p2 + λ3*p3 and λ1 + λ2 + λ3 = 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1373-L1379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.bilinear_interpolate-Tuple{AbstractMatrix{&lt;:Real}, Float64, Float64}" href="#Hammerhead.bilinear_interpolate-Tuple{AbstractMatrix{&lt;:Real}, Float64, Float64}"><code>Hammerhead.bilinear_interpolate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bilinear_interpolate(img, x, y) -&gt; pixel_value</code></pre><p>Bilinear interpolation of image intensity at non-integer coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray{&lt;:Real,2}</code> - Input image</li><li><code>x, y::Float64</code> - Coordinates to interpolate (1-indexed)</li></ul><p><strong>Returns</strong></p><ul><li><code>Real</code> - Interpolated pixel value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1867-L1878">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.calculate_correlation_moment-Tuple{AbstractMatrix, CartesianIndex}" href="#Hammerhead.calculate_correlation_moment-Tuple{AbstractMatrix, CartesianIndex}"><code>Hammerhead.calculate_correlation_moment</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_correlation_moment(correlation_magnitudes, peak_location) -&gt; moment</code></pre><p>Calculate normalized second moment of correlation peak as sharpness measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L653-L657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.calculate_quality_metrics-Tuple{AbstractMatrix, CartesianIndex, Real}" href="#Hammerhead.calculate_quality_metrics-Tuple{AbstractMatrix, CartesianIndex, Real}"><code>Hammerhead.calculate_quality_metrics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_quality_metrics(correlation_plane, peak_location, peak_value; robust=false) -&gt; (peak_ratio, correlation_moment)</code></pre><p>Calculate quality metrics for PIV correlation analysis.</p><p><strong>Arguments</strong></p><ul><li><code>correlation_plane</code> - Complex correlation result matrix</li><li><code>peak_location</code> - CartesianIndex of primary peak location</li><li><code>peak_value</code> - Magnitude of primary peak</li><li><code>robust=false</code> - Use robust local maxima method for secondary peak detection</li></ul><p><strong>Returns</strong></p><ul><li><code>peak_ratio::Float64</code> - Ratio of primary peak to secondary peak (higher is better)</li><li><code>correlation_moment::Float64</code> - Normalized correlation moment (measure of peak sharpness)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L467-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.compute_convergence_metric-Tuple{PIVResult, PIVResult}" href="#Hammerhead.compute_convergence_metric-Tuple{PIVResult, PIVResult}"><code>Hammerhead.compute_convergence_metric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_convergence_metric(result1, result2) -&gt; convergence_value</code></pre><p>Compute convergence metric between two PIV results.</p><p><strong>Arguments</strong></p><ul><li><code>result1, result2::PIVResult</code> - PIV results to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code> - RMS displacement difference in pixels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1915-L1925">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.compute_local_affine_transform-Tuple{Float64, Float64, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Tuple{Int64, Int64}}" href="#Hammerhead.compute_local_affine_transform-Tuple{Float64, Float64, AbstractVector, AbstractVector, AbstractVector, AbstractVector, Tuple{Int64, Int64}}"><code>Hammerhead.compute_local_affine_transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_local_affine_transform(px, py, x_coords, y_coords, u_disps, v_disps, window_size)</code></pre><p>Compute local affine transformation matrix at a specific point using nearby displacement vectors.</p><p>Fits a 2D affine transform (6 parameters) to displacement data within a local window. The transform maps from original coordinates to deformed coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>px, py::Float64</code> - Point where transform is computed</li><li><code>x_coords, y_coords::AbstractVector</code> - Coordinates of displacement vectors</li><li><code>u_disps, v_disps::AbstractVector</code> - Displacement components</li><li><code>window_size::Tuple{Int,Int}</code> - Size of local window for fitting</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code> - 3×3 homogeneous transformation matrix, or <code>nothing</code> if insufficient data</li></ul><p><strong>Transform Format</strong></p><pre><code class="nohighlight hljs">[a11 a12 tx]   [x]   [x + u]
[a21 a22 ty] * [y] = [y + v]  
[0   0   1 ]   [1]   [1    ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1762-L1785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.fill_symmetric_padding!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64, Int64, Tuple{Int64, Int64}}} where T" href="#Hammerhead.fill_symmetric_padding!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64, Int64, Tuple{Int64, Int64}}} where T"><code>Hammerhead.fill_symmetric_padding!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill_symmetric_padding!(padded, original, pad_top, pad_left, original_size)</code></pre><p>Fill padding regions using symmetric reflection to avoid discontinuities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L913-L917">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.find_containing_triangle-Tuple{AbstractMatrix, Real, Real}" href="#Hammerhead.find_containing_triangle-Tuple{AbstractMatrix, Real, Real}"><code>Hammerhead.find_containing_triangle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_containing_triangle(points, query_x, query_y)</code></pre><p>Find triangle containing the query point and return barycentric coordinates.</p><p>Returns (triangle<em>indices, barycentric</em>coords) or (nothing, nothing) if outside convex hull.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1340-L1346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.find_local_maxima-Tuple{AbstractMatrix}" href="#Hammerhead.find_local_maxima-Tuple{AbstractMatrix}"><code>Hammerhead.find_local_maxima</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_local_maxima(correlation_magnitudes) -&gt; Vector{CartesianIndex}</code></pre><p>Find all local maxima in correlation plane using robust peak detection. Identifies peaks by finding points that are local maxima in their immediate neighborhood, handling both sharp and broad peaks correctly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L585-L591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.find_secondary_peak-Tuple{AbstractMatrix, CartesianIndex, Real}" href="#Hammerhead.find_secondary_peak-Tuple{AbstractMatrix, CartesianIndex, Real}"><code>Hammerhead.find_secondary_peak</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_secondary_peak(correlation_magnitudes, primary_location, primary_value) -&gt; secondary_value</code></pre><p>Find the secondary peak in correlation plane, excluding region around primary peak. Uses super-fast approach: find global maximum, then exclude if it&#39;s near primary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L502-L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.find_secondary_peak_robust-Tuple{AbstractMatrix, CartesianIndex, Real}" href="#Hammerhead.find_secondary_peak_robust-Tuple{AbstractMatrix, CartesianIndex, Real}"><code>Hammerhead.find_secondary_peak_robust</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_secondary_peak_robust(correlation_magnitudes, primary_location, primary_value) -&gt; secondary_value</code></pre><p>Find the secondary peak using local maxima detection for robustness in high shear flows. More computationally expensive but handles closely spaced peaks better.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L556-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.generate_interrogation_grid-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}}" href="#Hammerhead.generate_interrogation_grid-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}}"><code>Hammerhead.generate_interrogation_grid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_interrogation_grid(image_size, window_size, overlap) -&gt; (grid_x, grid_y)</code></pre><p>Generate grid of interrogation window center positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1074-L1078">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.generate_window_1d-Tuple{Hammerhead.SimpleWindow, Int64}" href="#Hammerhead.generate_window_1d-Tuple{Hammerhead.SimpleWindow, Int64}"><code>Hammerhead.generate_window_1d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_window_1d(window_function, length) -&gt; window_vector</code></pre><p>Generate 1D window function using DSP.jl implementations for accuracy and performance. Supports both simple and parametric window functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L220-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.get_timer-Tuple{PIVResult}" href="#Hammerhead.get_timer-Tuple{PIVResult}"><code>Hammerhead.get_timer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_timer(result::PIVResult) -&gt; TimerOutput</code></pre><p>Get the timer data from a PIV result for analysis or integration with other timing systems. Returns a new TimerOutput if no timing data is available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.interpolate_vectors-Tuple{PIVResult}" href="#Hammerhead.interpolate_vectors-Tuple{PIVResult}"><code>Hammerhead.interpolate_vectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate_vectors(result::PIVResult; method=:linear_barycentric, 
                   target_status=:interpolated, source_status=:good)</code></pre><p>Interpolate vectors in PIV result to replace missing or bad vectors.</p><p><strong>Arguments</strong></p><ul><li><code>result::PIVResult</code>: PIV result to interpolate</li><li><code>method::Symbol</code>: Interpolation method (<code>:linear_barycentric</code>, <code>:nearest</code>)</li><li><code>target_status::Symbol</code>: Status to assign to interpolated vectors</li><li><code>source_status::Symbol</code>: Only use vectors with this status for interpolation</li></ul><p><strong>Returns</strong></p><ul><li>Modified PIVResult with interpolated vectors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1404-L1418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.is_area_preserving" href="#Hammerhead.is_area_preserving"><code>Hammerhead.is_area_preserving</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_area_preserving(matrix, tolerance=0.1) -&gt; Bool</code></pre><p>Check if a 2×2 matrix preserves area within tolerance. Area preservation means |det(A)| ≈ 1.</p><p><strong>Arguments</strong></p><ul><li><code>matrix::AbstractMatrix</code> - 2×2 transformation matrix</li><li><code>tolerance::Float64</code> - Relative tolerance for determinant check</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> - True if area-preserving within tolerance</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">is_area_preserving([1.0 0.1; -0.1 1.0])  # true (rotation + small shear)
is_area_preserving([2.0 0.0; 0.0 0.5])   # false (scales area by factor of 1.0 but violates uniformity)
is_area_preserving([1.05 0.0; 0.0 0.95]) # true (small uniform scaling, det ≈ 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1523-L1542">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.linear_barycentric_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}" href="#Hammerhead.linear_barycentric_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}"><code>Hammerhead.linear_barycentric_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_barycentric_interpolation(points, values, query_points; fallback_method=:nearest)</code></pre><p>Perform linear barycentric interpolation for scattered 2D data.</p><p>For each query point, finds the triangle containing it and computes the interpolated value using barycentric coordinates. If a point is outside the convex hull, uses fallback method.</p><p><strong>Arguments</strong></p><ul><li><code>points::AbstractMatrix</code>: Nx2 matrix of point coordinates [x y]</li><li><code>values::AbstractVector</code>: N-element vector of values at each point</li><li><code>query_points::AbstractMatrix</code>: Mx2 matrix of query point coordinates</li><li><code>fallback_method::Symbol</code>: Method for points outside convex hull (<code>:nearest</code>, <code>:zero</code>, <code>:nan</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Interpolated values at query points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1206-L1222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.linear_interpolation_2points-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, Symbol}" href="#Hammerhead.linear_interpolation_2points-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, Symbol}"><code>Hammerhead.linear_interpolation_2points</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_interpolation_2points(points, values, query_points, fallback_method)</code></pre><p>Linear interpolation between two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1294-L1298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.nearest_neighbor_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}" href="#Hammerhead.nearest_neighbor_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}"><code>Hammerhead.nearest_neighbor_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nearest_neighbor_interpolation(points, values, query_points)</code></pre><p>Simple nearest neighbor interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1491-L1495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.pad_to_size-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Int64, Int64}}} where T" href="#Hammerhead.pad_to_size-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Int64, Int64}}} where T"><code>Hammerhead.pad_to_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pad_to_size(subimg, target_size) -&gt; padded_array</code></pre><p>Pad a subimage to match target window size using symmetric padding. Uses the &#39;symmetric&#39; boundary condition which reflects values across the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L871-L876">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.run_iterative_deformation-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, PIVStage, PIVResult, TimerOutputs.TimerOutput}" href="#Hammerhead.run_iterative_deformation-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, PIVStage, PIVResult, TimerOutputs.TimerOutput}"><code>Hammerhead.run_iterative_deformation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_iterative_deformation(img1, img2, stage, initial_result, timer)</code></pre><p>Perform iterative deformation refinement of PIV analysis.</p><p>Uses initial displacement estimates to deform the second image iteratively, improving accuracy by reducing bias from large displacements.</p><p><strong>Arguments</strong></p><ul><li><code>img1::AbstractArray{&lt;:Real,2}</code> - First image </li><li><code>img2::AbstractArray{&lt;:Real,2}</code> - Second image</li><li><code>stage::PIVStage</code> - Processing stage configuration</li><li><code>initial_result::PIVResult</code> - Initial PIV analysis result</li><li><code>timer::TimerOutput</code> - Performance timing object</li></ul><p><strong>Returns</strong></p><ul><li><code>PIVResult</code> - Refined result after iterative deformation</li></ul><p><strong>Algorithm</strong></p><ol><li>Start with initial displacement estimates</li><li>For each iteration:<ul><li>Compute local affine transforms from displacement field</li><li>Validate transforms for area preservation and stability</li><li>Apply deformation to second image</li><li>Re-run PIV analysis on deformed images</li><li>Update displacement estimates</li><li>Check for convergence</li></ul></li><li>Return final refined results with convergence metadata</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1555-L1583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.run_piv-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#Hammerhead.run_piv-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>Hammerhead.run_piv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_piv(img1, img2; correlator=CrossCorrelator, kwargs...) -&gt; PIVResult
run_piv(img1, img2, stages::Vector{PIVStage}; correlator=CrossCorrelator, kwargs...) -&gt; Vector{PIVResult}</code></pre><p>Perform PIV analysis on image pair with single-stage or multi-stage processing.</p><p><strong>Arguments</strong></p><ul><li><code>img1::AbstractArray{&lt;:Real,2}</code> - First image  </li><li><code>img2::AbstractArray{&lt;:Real,2}</code> - Second image</li><li><code>stages::Vector{PIVStage}</code> - Optional multi-stage configuration</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>correlator</code> - Correlation method (default: CrossCorrelator)</li><li><code>window_size::Tuple{Int,Int}</code> - Window size for single-stage (default: (64,64))</li><li><code>overlap::Tuple{Float64,Float64}</code> - Overlap ratios (default: (0.5,0.5))</li></ul><p><strong>Returns</strong></p><ul><li><code>PIVResult</code> for single-stage processing</li><li><code>Vector{PIVResult}</code> for multi-stage processing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L780-L799">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.run_piv_stage-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, PIVStage, Any, TimerOutputs.TimerOutput}" href="#Hammerhead.run_piv_stage-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, PIVStage, Any, TimerOutputs.TimerOutput}"><code>Hammerhead.run_piv_stage</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_piv_stage(img1, img2, stage, correlator) -&gt; PIVResult</code></pre><p>Perform PIV analysis for a single stage with given configuration. Quality metrics and subpixel refinement are handled at this level for modularity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L963-L968">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Hammerhead.validate_affine_transform-Tuple{AbstractMatrix}" href="#Hammerhead.validate_affine_transform-Tuple{AbstractMatrix}"><code>Hammerhead.validate_affine_transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">validate_affine_transform(transform_matrix; tolerance=0.1) -&gt; Bool</code></pre><p>Validate an affine transformation matrix for use in iterative deformation. Checks area preservation and other physical constraints.</p><p><strong>Arguments</strong></p><ul><li><code>transform_matrix::AbstractMatrix</code> - 2×2 or 3×3 affine transformation matrix</li><li><code>tolerance::Float64</code> - Tolerance for area preservation check (default: 0.1)</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code> - True if transform is valid, false otherwise</li></ul><p><strong>Validation Criteria</strong></p><ul><li>Area preservation: |det(A)| ≈ 1 within tolerance</li><li>No excessive shear or rotation (condition number check)</li><li>Finite and real values only</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Valid identity transform
A = [1.0 0.0; 0.0 1.0]
validate_affine_transform(A)  # true

# Invalid transform (not area-preserving)
A = [2.0 0.0; 0.0 0.5]  # det = 1.0, but stretches by 2x and compresses by 0.5x
validate_affine_transform(A)  # false

# Valid small deformation
A = [1.05 0.02; -0.01 0.98]  # Small rotation and stretch
validate_affine_transform(A)  # likely true depending on tolerance</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/stillyslalom/Hammerhead.jl/blob/fd4e217d3c55bc065775ea2e3fdc8b358987d32c/src/Hammerhead.jl#L1113-L1145">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 18 July 2025 05:14">Friday 18 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
