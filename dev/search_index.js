var documenterSearchIndex = {"docs":
[{"location":"#Hammerhead","page":"Home","title":"Hammerhead","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Hammerhead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Hammerhead.PIVResult","page":"Home","title":"Hammerhead.PIVResult","text":"PIVResult\n\nContainer for complete PIV analysis results with property forwarding.\n\nFields\n\nvectors::StructArray{PIVVector} - Vector field data\nmetadata::Dict{String, Any} - Processing parameters and run information  \nauxiliary::Dict{String, Any} - Additional data (correlation planes, secondary peaks, etc.)\n\nProperty Forwarding\n\nProvides direct access to vector field properties:\n\nresult.x → result.vectors.x\nresult.u → result.vectors.u\netc.\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.PIVStage","page":"Home","title":"Hammerhead.PIVStage","text":"PIVStage{W<:WindowFunction, I<:InterpolationMethod}\n\nConfiguration for individual processing stage in multi-stage PIV analysis.\n\nFields\n\nwindow_size::Tuple{Int, Int} - Window dimensions (height, width)\noverlap::Tuple{Float64, Float64} - Overlap ratios (vertical, horizontal) ∈ [0, 1)\npadding::Int - Window padding pixels\ndeformation_iterations::Int - Number of deformation iterations\nwindow_function::W - Windowing function type\ninterpolation_method::I - Interpolation method type\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.PIVVector","page":"Home","title":"Hammerhead.PIVVector","text":"PIVVector\n\nIndividual vector data point containing position, displacement, and quality metrics.\n\nFields\n\nx::Float64 - Grid x-coordinate\ny::Float64 - Grid y-coordinate  \nu::Float64 - Displacement in x-direction\nv::Float64 - Displacement in y-direction\nstatus::Symbol - Vector status (:good, :interpolated, :bad, :secondary)\npeak_ratio::Float64 - Primary/secondary peak ratio\ncorrelation_moment::Float64 - Correlation peak sharpness metric\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.PIVStages-Tuple{Int64, Int64}","page":"Home","title":"Hammerhead.PIVStages","text":"PIVStages(n_stages::Int, final_size::Int; kwargs...) -> Vector{PIVStage}\n\nCreate a vector of PIVStage configurations for multi-stage PIV analysis with geometric window size progression.\n\nArguments\n\nn_stages::Int - Number of processing stages\nfinal_size::Int - Final window size (smallest stage)\n\nKeyword Arguments\n\nAll PIVStage parameters are supported with either scalar or vector values:\n\noverlap=0.5 - Overlap ratio(s). Can be scalar, tuple, or vector of scalars/tuples\npadding=0 - Padding pixel(s). Can be scalar or vector\ndeformation_iterations=3 - Deformation iteration(s). Can be scalar or vector  \nwindow_function=:rectangular - Window function(s). Can be symbol, tuple (symbol, params...), or vector thereof\ninterpolation_method=:bilinear - Interpolation method(s). Can be scalar symbol or vector of symbols\n\nParameter Handling\n\nScalar values: Applied to all stages\nVector values: Must have length 1 (applied to all) or length n_stages (one per stage)\nOverlap: Scalar values create symmetric overlap (val, val), tuples are used directly\n\nWindow Size Progression\n\nStages use geometric progression: final_size * 2^(n_stages - i) for stage i,  with minimum size constrained to final_size.\n\nExamples\n\n# Basic usage with scalar parameters\nstages = PIVStages(3, 32, overlap=0.5, window_function=:hanning)\n\n# Mixed scalar and vector parameters  \nstages = PIVStages(3, 32, overlap=[0.75, 0.5, 0.25], padding=5)\n\n# Different window functions per stage\nstages = PIVStages(2, 32, window_function=[:rectangular, :hanning])\n\n# Parametric window functions\nstages = PIVStages(3, 32, window_function=[(:kaiser, 5.0), :hanning, (:tukey, 0.3)])\n\n# Asymmetric overlap\nstages = PIVStages(2, 32, overlap=(0.6, 0.4))\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.analyze_correlation_plane-Tuple{AbstractMatrix}","page":"Home","title":"Hammerhead.analyze_correlation_plane","text":"analyze_correlation_plane(correlation_plane) -> (displacement, peak_ratio, correlation_moment)\n\nAnalyze correlation plane to extract displacement and quality metrics at PIV stage level. This allows the same analysis to be applied to results from different correlation algorithms.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.apply_window_function-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Hammerhead.WindowFunction}} where T","page":"Home","title":"Hammerhead.apply_window_function","text":"apply_window_function(subimage, window_function) -> windowed_subimage\n\nApply windowing function to subimage to reduce spectral leakage in correlation analysis. Uses DSP.jl implementations for mathematically correct and well-tested window functions.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.calculate_correlation_moment-Tuple{AbstractMatrix, CartesianIndex}","page":"Home","title":"Hammerhead.calculate_correlation_moment","text":"calculate_correlation_moment(correlation_magnitudes, peak_location) -> moment\n\nCalculate normalized second moment of correlation peak as sharpness measure.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.calculate_quality_metrics-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Home","title":"Hammerhead.calculate_quality_metrics","text":"calculate_quality_metrics(correlation_plane, peak_location, peak_value) -> (peak_ratio, correlation_moment)\n\nCalculate quality metrics for PIV correlation analysis.\n\nArguments\n\ncorrelation_plane - Complex correlation result matrix\npeak_location - CartesianIndex of primary peak location\npeak_value - Magnitude of primary peak\n\nReturns\n\npeak_ratio::Float64 - Ratio of primary peak to secondary peak (higher is better)\ncorrelation_moment::Float64 - Normalized correlation moment (measure of peak sharpness)\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.fill_symmetric_padding!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64, Int64, Tuple{Int64, Int64}}} where T","page":"Home","title":"Hammerhead.fill_symmetric_padding!","text":"fill_symmetric_padding!(padded, original, pad_top, pad_left, original_size)\n\nFill padding regions using symmetric reflection to avoid discontinuities.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.find_secondary_peak-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Home","title":"Hammerhead.find_secondary_peak","text":"find_secondary_peak(correlation_magnitudes, primary_location, primary_value) -> secondary_value\n\nFind the secondary peak in correlation plane, excluding region around primary peak.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.generate_interrogation_grid-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}}","page":"Home","title":"Hammerhead.generate_interrogation_grid","text":"generate_interrogation_grid(image_size, window_size, overlap) -> (grid_x, grid_y)\n\nGenerate grid of interrogation window center positions.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.generate_window_1d-Tuple{Hammerhead.SimpleWindow, Int64}","page":"Home","title":"Hammerhead.generate_window_1d","text":"generate_window_1d(window_function, length) -> window_vector\n\nGenerate 1D window function using DSP.jl implementations for accuracy and performance. Supports both simple and parametric window functions.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.pad_to_size-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Int64, Int64}}} where T","page":"Home","title":"Hammerhead.pad_to_size","text":"pad_to_size(subimg, target_size) -> padded_array\n\nPad a subimage to match target window size using symmetric padding. Uses the 'symmetric' boundary condition which reflects values across the boundary.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.run_piv-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Home","title":"Hammerhead.run_piv","text":"run_piv(img1, img2; correlator=CrossCorrelator, kwargs...) -> PIVResult\nrun_piv(img1, img2, stages::Vector{PIVStage}; correlator=CrossCorrelator, kwargs...) -> Vector{PIVResult}\n\nPerform PIV analysis on image pair with single-stage or multi-stage processing.\n\nArguments\n\nimg1::AbstractArray{<:Real,2} - First image  \nimg2::AbstractArray{<:Real,2} - Second image\nstages::Vector{PIVStage} - Optional multi-stage configuration\n\nKeyword Arguments\n\ncorrelator - Correlation method (default: CrossCorrelator)\nwindow_size::Tuple{Int,Int} - Window size for single-stage (default: (64,64))\noverlap::Tuple{Float64,Float64} - Overlap ratios (default: (0.5,0.5))\n\nReturns\n\nPIVResult for single-stage processing\nVector{PIVResult} for multi-stage processing\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.run_piv_stage-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage, Any}","page":"Home","title":"Hammerhead.run_piv_stage","text":"run_piv_stage(img1, img2, stage, correlator) -> PIVResult\n\nPerform PIV analysis for a single stage with given configuration. Quality metrics and subpixel refinement are handled at this level for modularity.\n\n\n\n\n\n","category":"method"}]
}
