var documenterSearchIndex = {"docs":
[{"location":"#Hammerhead.jl","page":"Home","title":"Hammerhead.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modern, high-performance Julia package for Particle Image Velocimetry (PIV) analysis, designed to provide capabilities on par with established tools while leveraging Julia's performance and ecosystem.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl provides a complete PIV analysis pipeline for experimental fluid dynamics applications. The package processes image pairs to extract velocity vector fields, supporting both simple single-stage analysis and sophisticated multi-stage processing for improved accuracy in challenging flow conditions.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Performance: Type-stable implementations with optimized FFT-based correlation\nFlexible Configuration: Multi-stage processing with configurable window sizes, overlap ratios, and windowing functions\nQuality Assessment: Built-in peak ratio and correlation moment metrics for vector validation\nModern Architecture: Clean APIs with property forwarding and symbol-based configuration\nComprehensive Windowing: Support for all DSP.jl windowing functions (Hanning, Hamming, Blackman, Kaiser, etc.)\nRobust Processing: Boundary handling with symmetric padding and graceful error recovery","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-PIV-Analysis","page":"Home","title":"Basic PIV Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Hammerhead\n\n# Load your image pair\nimg1 = load(\"image1.tif\")\nimg2 = load(\"image2.tif\")\n\n# Perform single-stage PIV analysis\nresult = run_piv(img1, img2, window_size=(64, 64), overlap=(0.5, 0.5))\n\n# Access results with clean API\ndisplacement_x = result.u  # X-direction displacements\ndisplacement_y = result.v  # Y-direction displacements\npositions_x = result.x     # Grid x-coordinates\npositions_y = result.y     # Grid y-coordinates\nquality = result.peak_ratio # Quality metrics","category":"page"},{"location":"#Multi-Stage-Processing","page":"Home","title":"Multi-Stage Processing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Create multi-stage configuration for improved accuracy\nstages = PIVStages(3, 32,  # 3 stages ending at 32×32 windows\n                   overlap=0.5,\n                   window_function=:hanning)\n\n# Perform multi-stage analysis\nresults = run_piv(img1, img2, stages)\n\n# Access final stage results\nfinal_result = results[end]","category":"page"},{"location":"#Advanced-Configuration","page":"Home","title":"Advanced Configuration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Custom stage configuration with different parameters\nstage1 = PIVStage((128, 128), overlap=(0.75, 0.75), window_function=:rectangular)\nstage2 = PIVStage((64, 64), overlap=(0.5, 0.5), window_function=:hanning)\nstage3 = PIVStage((32, 32), overlap=(0.25, 0.25), window_function=(:kaiser, 5.0))\n\nresults = run_piv(img1, img2, [stage1, stage2, stage3])","category":"page"},{"location":"#Performance-Timing","page":"Home","title":"Performance Timing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl automatically instruments all PIV operations with detailed timing data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Run PIV analysis (timing is automatic)\nresult = run_piv(img1, img2, window_size=(64, 64))\n\n# Access timing information\nusing TimerOutputs  # Need to import for print_timer\ntimer = get_timer(result)\nprint_timer(timer)  # Prints detailed timing breakdown\n\n# For multi-stage analysis, timing is in the first result\nresults = run_piv(img1, img2, stages)\ntimer = get_timer(results[1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Timing data includes hierarchical breakdown of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"FFT operations (forward, inverse, setup)\nCross-correlation computation  \nPeak analysis and subpixel refinement\nWindow processing and padding\nGrid generation and result assembly","category":"page"},{"location":"#Core-Data-Structures","page":"Home","title":"Core Data Structures","text":"","category":"section"},{"location":"#PIVVector","page":"Home","title":"PIVVector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Individual vector measurement containing position, displacement, and quality metrics.","category":"page"},{"location":"#PIVResult","page":"Home","title":"PIVResult","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Container for complete analysis results with property forwarding for ergonomic access:","category":"page"},{"location":"","page":"Home","title":"Home","text":"result.x, result.y - Grid positions\nresult.u, result.v - Displacement components  \nresult.peak_ratio - Primary/secondary peak ratio\nresult.correlation_moment - Correlation peak sharpness","category":"page"},{"location":"#PIVStage","page":"Home","title":"PIVStage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Configuration for individual processing stages with type-safe parameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Window size and overlap ratios\nWindowing functions (rectangular, Hanning, Hamming, Blackman, Kaiser, etc.)\nInterpolation methods\nDeformation iterations","category":"page"},{"location":"#Windowing-Functions","page":"Home","title":"Windowing Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl leverages DSP.jl for mathematically correct windowing functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Simple windows\nPIVStage((64, 64), window_function=:hanning)\nPIVStage((64, 64), window_function=:blackman)\n\n# Parametric windows  \nPIVStage((64, 64), window_function=(:kaiser, 5.0))\nPIVStage((64, 64), window_function=(:tukey, 0.3))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supported functions include: :rectangular, :hanning, :hamming, :blackman, :bartlett, :cosine, :lanczos, :triang, :kaiser, :tukey, :gaussian.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Optimized for large image processing with fast correlation algorithms\nMemory efficient processing of extensive datasets \nType-stable implementations throughout for optimal performance","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Hammerhead\")","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Hammerhead.PIVResult","page":"Home","title":"Hammerhead.PIVResult","text":"PIVResult\n\nContainer for complete PIV analysis results with property forwarding.\n\nFields\n\nvectors::StructArray{PIVVector} - Vector field data\nmetadata::Dict{String, Any} - Processing parameters and run information  \nauxiliary::Dict{String, Any} - Additional data (correlation planes, secondary peaks, etc.)\n\nProperty Forwarding\n\nProvides direct access to vector field properties:\n\nresult.x → result.vectors.x\nresult.u → result.vectors.u\netc.\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.PIVStage","page":"Home","title":"Hammerhead.PIVStage","text":"PIVStage{W<:WindowFunction, I<:InterpolationMethod}\n\nConfiguration for individual processing stage in multi-stage PIV analysis.\n\nFields\n\nwindow_size::Tuple{Int, Int} - Window dimensions (height, width)\noverlap::Tuple{Float64, Float64} - Overlap ratios (vertical, horizontal) ∈ [0, 1)\npadding::Int - Window padding pixels\ndeformation_iterations::Int - Number of deformation iterations\nwindow_function::W - Windowing function type\ninterpolation_method::I - Interpolation method type\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.PIVVector","page":"Home","title":"Hammerhead.PIVVector","text":"PIVVector\n\nIndividual vector data point containing position, displacement, and quality metrics.\n\nFields\n\nx::Float64 - Grid x-coordinate\ny::Float64 - Grid y-coordinate  \nu::Float64 - Displacement in x-direction\nv::Float64 - Displacement in y-direction\nstatus::Symbol - Vector status (:good, :interpolated, :bad, :secondary)\npeak_ratio::Float64 - Primary/secondary peak ratio\ncorrelation_moment::Float64 - Correlation peak sharpness metric\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.PIVStages-Tuple{Int64, Int64}","page":"Home","title":"Hammerhead.PIVStages","text":"PIVStages(n_stages::Int, final_size::Int; kwargs...) -> Vector{PIVStage}\n\nCreate a vector of PIVStage configurations for multi-stage PIV analysis with geometric window size progression.\n\nArguments\n\nn_stages::Int - Number of processing stages\nfinal_size::Int - Final window size (smallest stage)\n\nKeyword Arguments\n\nAll PIVStage parameters are supported with either scalar or vector values:\n\noverlap=0.5 - Overlap ratio(s). Can be scalar, tuple, or vector of scalars/tuples\npadding=0 - Padding pixel(s). Can be scalar or vector\ndeformation_iterations=3 - Deformation iteration(s). Can be scalar or vector  \nwindow_function=:rectangular - Window function(s). Can be symbol, tuple (symbol, params...), or vector thereof\ninterpolation_method=:bilinear - Interpolation method(s). Can be scalar symbol or vector of symbols\n\nParameter Handling\n\nScalar values: Applied to all stages\nVector values: Must have length 1 (applied to all) or length n_stages (one per stage)\nOverlap: Scalar values create symmetric overlap (val, val), tuples are used directly\n\nWindow Size Progression\n\nStages use geometric progression: final_size * 2^(n_stages - i) for stage i,  with minimum size constrained to final_size.\n\nExamples\n\n# Basic usage with scalar parameters\nstages = PIVStages(3, 32, overlap=0.5, window_function=:hanning)\n\n# Mixed scalar and vector parameters  \nstages = PIVStages(3, 32, overlap=[0.75, 0.5, 0.25], padding=5)\n\n# Different window functions per stage\nstages = PIVStages(2, 32, window_function=[:rectangular, :hanning])\n\n# Parametric window functions\nstages = PIVStages(3, 32, window_function=[(:kaiser, 5.0), :hanning, (:tukey, 0.3)])\n\n# Asymmetric overlap\nstages = PIVStages(2, 32, overlap=(0.6, 0.4))\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.analyze_correlation_plane-Tuple{AbstractMatrix}","page":"Home","title":"Hammerhead.analyze_correlation_plane","text":"analyze_correlation_plane(correlation_plane) -> (displacement, peak_ratio, correlation_moment)\n\nAnalyze correlation plane to extract displacement and quality metrics at PIV stage level. This allows the same analysis to be applied to results from different correlation algorithms.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.apply_window_function-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Hammerhead.WindowFunction}} where T","page":"Home","title":"Hammerhead.apply_window_function","text":"apply_window_function(subimage, window_function) -> windowed_subimage\n\nApply windowing function to subimage to reduce spectral leakage in correlation analysis. Uses DSP.jl implementations for mathematically correct and well-tested window functions.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.barycentric_coordinates-NTuple{4, AbstractVector}","page":"Home","title":"Hammerhead.barycentric_coordinates","text":"barycentric_coordinates(p1, p2, p3, query)\n\nCompute barycentric coordinates of query point with respect to triangle p1-p2-p3.\n\nReturns (λ1, λ2, λ3) such that query = λ1p1 + λ2p2 + λ3*p3 and λ1 + λ2 + λ3 = 1.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.calculate_correlation_moment-Tuple{AbstractMatrix, CartesianIndex}","page":"Home","title":"Hammerhead.calculate_correlation_moment","text":"calculate_correlation_moment(correlation_magnitudes, peak_location) -> moment\n\nCalculate normalized second moment of correlation peak as sharpness measure.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.calculate_quality_metrics-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Home","title":"Hammerhead.calculate_quality_metrics","text":"calculate_quality_metrics(correlation_plane, peak_location, peak_value; robust=false) -> (peak_ratio, correlation_moment)\n\nCalculate quality metrics for PIV correlation analysis.\n\nArguments\n\ncorrelation_plane - Complex correlation result matrix\npeak_location - CartesianIndex of primary peak location\npeak_value - Magnitude of primary peak\nrobust=false - Use robust local maxima method for secondary peak detection\n\nReturns\n\npeak_ratio::Float64 - Ratio of primary peak to secondary peak (higher is better)\ncorrelation_moment::Float64 - Normalized correlation moment (measure of peak sharpness)\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.fill_symmetric_padding!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64, Int64, Tuple{Int64, Int64}}} where T","page":"Home","title":"Hammerhead.fill_symmetric_padding!","text":"fill_symmetric_padding!(padded, original, pad_top, pad_left, original_size)\n\nFill padding regions using symmetric reflection to avoid discontinuities.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.find_containing_triangle-Tuple{AbstractMatrix, Real, Real}","page":"Home","title":"Hammerhead.find_containing_triangle","text":"find_containing_triangle(points, query_x, query_y)\n\nFind triangle containing the query point and return barycentric coordinates.\n\nReturns (triangleindices, barycentriccoords) or (nothing, nothing) if outside convex hull.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.find_local_maxima-Tuple{AbstractMatrix}","page":"Home","title":"Hammerhead.find_local_maxima","text":"find_local_maxima(correlation_magnitudes) -> Vector{CartesianIndex}\n\nFind all local maxima in correlation plane using robust peak detection. Identifies peaks by finding points that are local maxima in their immediate neighborhood, handling both sharp and broad peaks correctly.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.find_secondary_peak-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Home","title":"Hammerhead.find_secondary_peak","text":"find_secondary_peak(correlation_magnitudes, primary_location, primary_value) -> secondary_value\n\nFind the secondary peak in correlation plane, excluding region around primary peak. Uses super-fast approach: find global maximum, then exclude if it's near primary.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.find_secondary_peak_robust-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Home","title":"Hammerhead.find_secondary_peak_robust","text":"find_secondary_peak_robust(correlation_magnitudes, primary_location, primary_value) -> secondary_value\n\nFind the secondary peak using local maxima detection for robustness in high shear flows. More computationally expensive but handles closely spaced peaks better.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.generate_interrogation_grid-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}}","page":"Home","title":"Hammerhead.generate_interrogation_grid","text":"generate_interrogation_grid(image_size, window_size, overlap) -> (grid_x, grid_y)\n\nGenerate grid of interrogation window center positions.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.generate_window_1d-Tuple{Hammerhead.SimpleWindow, Int64}","page":"Home","title":"Hammerhead.generate_window_1d","text":"generate_window_1d(window_function, length) -> window_vector\n\nGenerate 1D window function using DSP.jl implementations for accuracy and performance. Supports both simple and parametric window functions.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.get_timer-Tuple{PIVResult}","page":"Home","title":"Hammerhead.get_timer","text":"get_timer(result::PIVResult) -> TimerOutput\n\nGet the timer data from a PIV result for analysis or integration with other timing systems. Returns a new TimerOutput if no timing data is available.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.interpolate_vectors-Tuple{PIVResult}","page":"Home","title":"Hammerhead.interpolate_vectors","text":"interpolate_vectors(result::PIVResult; method=:linear_barycentric, \n                   target_status=:interpolated, source_status=:good)\n\nInterpolate vectors in PIV result to replace missing or bad vectors.\n\nArguments\n\nresult::PIVResult: PIV result to interpolate\nmethod::Symbol: Interpolation method (:linear_barycentric, :nearest)\ntarget_status::Symbol: Status to assign to interpolated vectors\nsource_status::Symbol: Only use vectors with this status for interpolation\n\nReturns\n\nModified PIVResult with interpolated vectors\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.is_area_preserving","page":"Home","title":"Hammerhead.is_area_preserving","text":"is_area_preserving(matrix, tolerance=0.1) -> Bool\n\nCheck if a 2×2 matrix preserves area within tolerance. Area preservation means |det(A)| ≈ 1.\n\nArguments\n\nmatrix::AbstractMatrix - 2×2 transformation matrix\ntolerance::Float64 - Relative tolerance for determinant check\n\nReturns\n\nBool - True if area-preserving within tolerance\n\nExamples\n\nis_area_preserving([1.0 0.1; -0.1 1.0])  # true (rotation + small shear)\nis_area_preserving([2.0 0.0; 0.0 0.5])   # false (scales area by factor of 1.0 but violates uniformity)\nis_area_preserving([1.05 0.0; 0.0 0.95]) # true (small uniform scaling, det ≈ 1.0)\n\n\n\n\n\n","category":"function"},{"location":"#Hammerhead.linear_barycentric_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Home","title":"Hammerhead.linear_barycentric_interpolation","text":"linear_barycentric_interpolation(points, values, query_points; fallback_method=:nearest)\n\nPerform linear barycentric interpolation for scattered 2D data.\n\nFor each query point, finds the triangle containing it and computes the interpolated value using barycentric coordinates. If a point is outside the convex hull, uses fallback method.\n\nArguments\n\npoints::AbstractMatrix: Nx2 matrix of point coordinates [x y]\nvalues::AbstractVector: N-element vector of values at each point\nquery_points::AbstractMatrix: Mx2 matrix of query point coordinates\nfallback_method::Symbol: Method for points outside convex hull (:nearest, :zero, :nan)\n\nReturns\n\nVector: Interpolated values at query points\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.linear_interpolation_2points-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, Symbol}","page":"Home","title":"Hammerhead.linear_interpolation_2points","text":"linear_interpolation_2points(points, values, query_points, fallback_method)\n\nLinear interpolation between two points.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.nearest_neighbor_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Home","title":"Hammerhead.nearest_neighbor_interpolation","text":"nearest_neighbor_interpolation(points, values, query_points)\n\nSimple nearest neighbor interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.pad_to_size-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Int64, Int64}}} where T","page":"Home","title":"Hammerhead.pad_to_size","text":"pad_to_size(subimg, target_size) -> padded_array\n\nPad a subimage to match target window size using symmetric padding. Uses the 'symmetric' boundary condition which reflects values across the boundary.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.run_piv-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}}","page":"Home","title":"Hammerhead.run_piv","text":"run_piv(img1, img2; correlator=CrossCorrelator, kwargs...) -> PIVResult\nrun_piv(img1, img2, stages::Vector{PIVStage}; correlator=CrossCorrelator, kwargs...) -> Vector{PIVResult}\n\nPerform PIV analysis on image pair with single-stage or multi-stage processing.\n\nArguments\n\nimg1::AbstractArray{<:Real,2} - First image  \nimg2::AbstractArray{<:Real,2} - Second image\nstages::Vector{PIVStage} - Optional multi-stage configuration\n\nKeyword Arguments\n\ncorrelator - Correlation method (default: CrossCorrelator)\nwindow_size::Tuple{Int,Int} - Window size for single-stage (default: (64,64))\noverlap::Tuple{Float64,Float64} - Overlap ratios (default: (0.5,0.5))\n\nReturns\n\nPIVResult for single-stage processing\nVector{PIVResult} for multi-stage processing\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.run_piv_stage-Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage, Any, TimerOutputs.TimerOutput}","page":"Home","title":"Hammerhead.run_piv_stage","text":"run_piv_stage(img1, img2, stage, correlator) -> PIVResult\n\nPerform PIV analysis for a single stage with given configuration. Quality metrics and subpixel refinement are handled at this level for modularity.\n\n\n\n\n\n","category":"method"},{"location":"#Hammerhead.validate_affine_transform-Tuple{AbstractMatrix}","page":"Home","title":"Hammerhead.validate_affine_transform","text":"validate_affine_transform(transform_matrix; tolerance=0.1) -> Bool\n\nValidate an affine transformation matrix for use in iterative deformation. Checks area preservation and other physical constraints.\n\nArguments\n\ntransform_matrix::AbstractMatrix - 2×2 or 3×3 affine transformation matrix\ntolerance::Float64 - Tolerance for area preservation check (default: 0.1)\n\nReturns\n\nBool - True if transform is valid, false otherwise\n\nValidation Criteria\n\nArea preservation: |det(A)| ≈ 1 within tolerance\nNo excessive shear or rotation (condition number check)\nFinite and real values only\n\nExamples\n\n# Valid identity transform\nA = [1.0 0.0; 0.0 1.0]\nvalidate_affine_transform(A)  # true\n\n# Invalid transform (not area-preserving)\nA = [2.0 0.0; 0.0 0.5]  # det = 1.0, but stretches by 2x and compresses by 0.5x\nvalidate_affine_transform(A)  # false\n\n# Valid small deformation\nA = [1.05 0.02; -0.01 0.98]  # Small rotation and stretch\nvalidate_affine_transform(A)  # likely true depending on tolerance\n\n\n\n\n\n","category":"method"}]
}
