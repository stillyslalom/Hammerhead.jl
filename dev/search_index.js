var documenterSearchIndex = {"docs":
[{"location":"function_ref/#API-Reference","page":"Function Reference","title":"API Reference","text":"","category":"section"},{"location":"function_ref/","page":"Function Reference","title":"Function Reference","text":"","category":"page"},{"location":"function_ref/#Hammerhead.PIVStages-Tuple{Int64, Int64}","page":"Function Reference","title":"Hammerhead.PIVStages","text":"PIVStages(n_stages::Int, final_size::Int; kwargs...) -> Vector{PIVStage}\n\nCreate a vector of PIVStage configurations for multi-stage PIV analysis with geometric window size progression.\n\nArguments\n\nn_stages::Int - Number of processing stages\nfinal_size::Int - Final window size (smallest stage)\n\nKeyword Arguments\n\nAll PIVStage parameters are supported with either scalar or vector values:\n\noverlap=0.5 - Overlap ratio(s). Can be scalar, tuple, or vector of scalars/tuples\npadding=0 - Padding pixel(s). Can be scalar or vector\ndeformation_iterations=3 - Deformation iteration(s). Can be scalar or vector  \nwindow_function=:rectangular - Window function(s). Can be symbol, tuple (symbol, params...), or vector thereof\ninterpolation_method=:bilinear - Interpolation method(s). Can be scalar symbol or vector of symbols\n\nParameter Handling\n\nScalar values: Applied to all stages\nVector values: Must have length 1 (applied to all) or length n_stages (one per stage)\nOverlap: Scalar values create symmetric overlap (val, val), tuples are used directly\n\nWindow Size Progression\n\nStages use geometric progression: final_size * 2^(n_stages - i) for stage i,  with minimum size constrained to final_size.\n\nExamples\n\n# Basic usage with scalar parameters\nstages = PIVStages(3, 32, overlap=0.5, window_function=:hanning)\n\n# Mixed scalar and vector parameters  \nstages = PIVStages(3, 32, overlap=[0.75, 0.5, 0.25], padding=5)\n\n# Different window functions per stage\nstages = PIVStages(2, 32, window_function=[:rectangular, :hanning])\n\n# Parametric window functions\nstages = PIVStages(3, 32, window_function=[(:kaiser, 5.0), :hanning, (:tukey, 0.3)])\n\n# Asymmetric overlap\nstages = PIVStages(2, 32, overlap=(0.6, 0.4))\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.plot_piv-Tuple{AbstractMatrix, PIVResult}","page":"Function Reference","title":"Hammerhead.plot_piv","text":"plot_piv(background_image, piv_result; kwargs...) -> Figure\n\nCreate an interactive vector plot of PIV results overlaid on a background image. Vectors are colored by their status and scaled for visibility.\n\nArguments\n\nbackground_image::AbstractMatrix - Background image to display\npiv_result::PIVResult - PIV analysis results to visualize\n\nKeyword Arguments\n\nscale::Float64 = 5.0 - Vector scaling factor for visibility\narrow_size::Float64 = 0.02 - Width of vector arrowheads (relative to plot size)\ncolormap_good = :viridis - Colormap for good vectors (by magnitude)\nshow_bad::Bool = true - Whether to show bad/interpolated vectors\ntitle::String = \"PIV Results\" - Plot title\nvector_width::Float64 = 2.0 - Line width for vectors\n\nVector Status Colors\n\n:good - Colored by velocity magnitude using specified colormap\n:interpolated - Orange\n:bad - Red\n:secondary - Yellow\n\nReturns\n\nFigure - CairoMakie figure object that can be displayed or saved\n\nExamples\n\n# Basic usage\nfig = plot_piv(img1, result)\ndisplay(fig)\n\n# Customized visualization\nfig = plot_piv(img1, result, \n                      scale=10.0, \n                      colormap_good=:plasma,\n                      title=\"PIV Analysis - Flow Field\")\n\nRequirements\n\nRequires CairoMakie.jl to be loaded: using CairoMakie\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.run_piv-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Union{Real, ColorTypes.Gray}","page":"Function Reference","title":"Hammerhead.run_piv","text":"run_piv(img1, img2; correlator=CrossCorrelator, kwargs...) -> PIVResult\nrun_piv(img1, img2, stages::Vector{PIVStage}; correlator=CrossCorrelator, kwargs...) -> Vector{PIVResult}\n\nPerform PIV analysis on image pair with single-stage or multi-stage processing.\n\nArguments\n\nimg1::AbstractArray{<:Real,2} - First image  \nimg2::AbstractArray{<:Real,2} - Second image\nstages::Vector{PIVStage} - Optional multi-stage configuration\n\nKeyword Arguments\n\nwindow_size::Tuple{Int,Int} - Window size for single-stage (default: (64,64))\noverlap::Tuple{Float64,Float64} - Overlap ratios (default: (0.5,0.5))\n\nReturns\n\nPIVResult for single-stage processing\nVector{PIVResult} for multi-stage processing\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.PIVResult","page":"Function Reference","title":"Hammerhead.PIVResult","text":"PIVResult\n\nContainer for complete PIV analysis results with property forwarding.\n\nFields\n\nvectors::StructArray{PIVVector} - Vector field data\nmetadata::Dict{String, Any} - Processing parameters and run information  \nauxiliary::Dict{String, Any} - Additional data (correlation planes, secondary peaks, etc.)\n\nProperty Forwarding\n\nProvides direct access to vector field properties:\n\nresult.x → result.vectors.x\nresult.u → result.vectors.u\netc.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.PIVStage","page":"Function Reference","title":"Hammerhead.PIVStage","text":"PIVStage{W<:WindowFunction, I<:InterpolationMethod}\n\nConfiguration for individual processing stage in multi-stage PIV analysis.\n\nFields\n\nwindow_size::Tuple{Int, Int} - Window dimensions (height, width)\noverlap::Tuple{Float64, Float64} - Overlap ratios (vertical, horizontal) ∈ [0, 1)\npadding::Int - Window padding pixels\ndeformation_iterations::Int - Number of deformation iterations\nwindow_function::W - Windowing function type\ninterpolation_method::I - Interpolation method type\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.PIVVector","page":"Function Reference","title":"Hammerhead.PIVVector","text":"PIVVector\n\nIndividual vector data point containing position, displacement, and quality metrics.\n\nFields\n\nx::Float64 - Grid x-coordinate\ny::Float64 - Grid y-coordinate  \nu::Float64 - Displacement in x-direction\nv::Float64 - Displacement in y-direction\nstatus::Symbol - Vector status (:good, :interpolated, :bad, :secondary)\npeak_ratio::Float64 - Primary/secondary peak ratio\ncorrelation_moment::Float64 - Correlation peak sharpness metric\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.jl","page":"Home","title":"Hammerhead.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modern, high-performance Julia package for Particle Image Velocimetry (PIV) analysis, designed to provide capabilities on par with established tools while leveraging Julia's performance and ecosystem.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl provides a 2D PIV analysis pipeline for experimental fluid dynamics. The package processes image pairs to extract velocity vector fields, supporting both simple single-stage analysis and sophisticated multi-stage processing (in-progress) for improved accuracy in challenging flow conditions.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Performance: Type-stable implementations with optimized FFT-based correlation and parallel processing\nParallel Processing: Thread-safe multi-core processing using ChunkSplitters.jl for optimal work distribution\nMemory Efficient: Per-thread caches with pre-computed window functions and pre-allocated buffers\nFlexible Configuration: Multi-stage processing with configurable window sizes, overlap ratios, and windowing functions\nQuality Assessment: Built-in peak ratio and correlation moment metrics for vector validation\nModern Architecture: Clean APIs with property forwarding and symbol-based configuration\nComprehensive Windowing: Support for all DSP.jl windowing functions (Hanning, Hamming, Blackman, Kaiser, etc.)\nRobust Processing: Boundary handling with symmetric padding and graceful error recovery\nDetailed Timing: Comprehensive performance instrumentation with TimerOutputs.jl integration","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-PIV-Analysis","page":"Home","title":"Basic PIV Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Hammerhead\n\n# Load your image pair\nimg1 = load(\"image1.tif\")\nimg2 = load(\"image2.tif\")\n\n# Perform single-stage PIV analysis\nresult = run_piv(img1, img2, window_size=(64, 64), overlap=(0.5, 0.5))\n\n# Access results with clean API\ndisplacement_x = result.u  # X-direction displacements\ndisplacement_y = result.v  # Y-direction displacements\npositions_x = result.x     # Grid x-coordinates\npositions_y = result.y     # Grid y-coordinates\nquality = result.peak_ratio # Quality metrics","category":"page"},{"location":"#Multi-Stage-Processing","page":"Home","title":"Multi-Stage Processing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Create multi-stage configuration for improved accuracy\nstages = PIVStages(3, 32,  # 3 stages ending at 32×32 windows\n                   overlap=0.5,\n                   window_function=:hanning)\n\n# Perform multi-stage analysis\nresults = run_piv(img1, img2, stages)\n\n# Access final stage results\nfinal_result = results[end]","category":"page"},{"location":"#Advanced-Configuration","page":"Home","title":"Advanced Configuration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Custom stage configuration with different parameters\nstage1 = PIVStage((128, 128), overlap=(0.75, 0.75), window_function=:rectangular)\nstage2 = PIVStage((64, 64), overlap=(0.5, 0.5), window_function=:hanning)\nstage3 = PIVStage((32, 32), overlap=(0.25, 0.25), window_function=(:kaiser, 5.0))\n\nresults = run_piv(img1, img2, [stage1, stage2, stage3])","category":"page"},{"location":"#Performance-Timing","page":"Home","title":"Performance Timing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl automatically instruments all PIV operations with detailed timing data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Run PIV analysis (timing is automatic)\nresult = run_piv(img1, img2, window_size=(64, 64))\n\n# Access timing information\nusing TimerOutputs  # Need to import for print_timer\ntimer = get_timer(result)\nprint_timer(timer)  # Prints detailed timing breakdown\n\n# For multi-stage analysis, timing is in the first result\nresults = run_piv(img1, img2, stages)\ntimer = get_timer(results[1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Timing data includes hierarchical breakdown of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"FFT operations (forward, inverse, setup)\nCross-correlation computation  \nPeak analysis and subpixel refinement\nParallel window processing with thread-level detail\nGrid generation and cache allocation\nResult assembly and merging","category":"page"},{"location":"#Core-Data-Structures","page":"Home","title":"Core Data Structures","text":"","category":"section"},{"location":"#PIVVector","page":"Home","title":"PIVVector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Individual vector measurement containing position, displacement, and quality metrics.","category":"page"},{"location":"#PIVResult","page":"Home","title":"PIVResult","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Container for complete analysis results with property forwarding for ergonomic access:","category":"page"},{"location":"","page":"Home","title":"Home","text":"result.x, result.y - Grid positions\nresult.u, result.v - Displacement components  \nresult.peak_ratio - Primary/secondary peak ratio\nresult.correlation_moment - Correlation peak sharpness","category":"page"},{"location":"#PIVStage","page":"Home","title":"PIVStage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Configuration for individual processing stages with type-safe parameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Window size and overlap ratios\nWindowing functions (rectangular, Hanning, Hamming, Blackman, Kaiser, etc.)\nInterpolation methods\nDeformation iterations","category":"page"},{"location":"#Windowing-Functions","page":"Home","title":"Windowing Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl leverages DSP.jl for mathematically correct windowing functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Simple windows\nPIVStage((64, 64), window_function=:hanning)\nPIVStage((64, 64), window_function=:blackman)\n\n# Parametric windows  \nPIVStage((64, 64), window_function=(:kaiser, 5.0))\nPIVStage((64, 64), window_function=(:tukey, 0.3))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supported functions include: :rectangular, :hanning, :hamming, :blackman, :bartlett, :cosine, :lanczos, :triang, :kaiser, :tukey, :gaussian.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parallel Processing: Automatic multi-threaded execution using ChunkSplitters.jl for optimal CPU utilization\nMemory Efficiency: Per-thread caches eliminate repeated allocations and window function computations\nOptimized Algorithms: Fast FFT-based correlation with pre-allocated buffers and type-stable implementations\nScalable Design: Efficient processing of large datasets with minimal memory overhead\nPerformance Monitoring: Built-in timing instrumentation for performance analysis and optimization","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl delivers excellent performance with near-linear scaling across available CPU cores, making it suitable for both interactive analysis and high-throughput batch processing.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/stillyslalom/Hammerhead.jl\")","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"internals/#Hammerhead.analyze_correlation_plane","page":"Internals","title":"Hammerhead.analyze_correlation_plane","text":"analyze_correlation_plane(correlation_plane) -> (displacement, peak_ratio, correlation_moment)\n\nAnalyze correlation plane to extract displacement and quality metrics at PIV stage level. This allows the same analysis to be applied to results from different correlation algorithms.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Hammerhead.apply_cached_window!-Union{Tuple{T2}, Tuple{T1}, Tuple{Hammerhead.PIVStageCache{T1}, AbstractArray{T2}, AbstractArray{T2}}} where {T1, T2}","page":"Internals","title":"Hammerhead.apply_cached_window!","text":"apply_cached_window!(cache, subimg1, subimg2) -> (windowed1, windowed2)\n\nApply pre-computed window function to both subimages using pre-allocated buffers. Returns references to the cached windowed image buffers for efficient memory usage.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.apply_window!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T}}} where T","page":"Internals","title":"Hammerhead.apply_window!","text":"apply_window!(subimage, window) -> windowed_subimage\n\nApply windowing array to subimage to reduce spectral leakage in correlation analysis.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.barycentric_coordinates-NTuple{4, AbstractVector}","page":"Internals","title":"Hammerhead.barycentric_coordinates","text":"barycentric_coordinates(p1, p2, p3, query)\n\nCompute barycentric coordinates of query point with respect to triangle p1-p2-p3.\n\nReturns (λ1, λ2, λ3) such that query = λ1p1 + λ2p2 + λ3*p3 and λ1 + λ2 + λ3 = 1.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.build_window-Tuple{Any, Hammerhead.WindowFunction}","page":"Internals","title":"Hammerhead.build_window","text":"build_window(size, window_function) -> window\n\nBuild a 2D window function for the given size using the specified window function type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.calculate_correlation_moment-Tuple{AbstractMatrix, CartesianIndex}","page":"Internals","title":"Hammerhead.calculate_correlation_moment","text":"calculate_correlation_moment(correlation_magnitudes, peak_location) -> moment\n\nCalculate normalized second moment of correlation peak as sharpness measure.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.calculate_quality_metrics-Union{Tuple{T}, Tuple{AbstractMatrix{T}, CartesianIndex, Real}} where T","page":"Internals","title":"Hammerhead.calculate_quality_metrics","text":"calculate_quality_metrics(correlation_plane, peak_location, peak_value; robust=false) -> (peak_ratio, correlation_moment)\n\nCalculate quality metrics for PIV correlation analysis.\n\nArguments\n\ncorrelation_plane - Complex correlation result matrix\npeak_location - CartesianIndex of primary peak location\npeak_value - Magnitude of primary peak\nrobust=false - Use robust local maxima method for secondary peak detection\n\nReturns\n\npeak_ratio::Float64 - Ratio of primary peak to secondary peak (higher is better)\ncorrelation_moment::Float64 - Normalized correlation moment (measure of peak sharpness)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.fill_symmetric_padding!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64, Int64, Tuple{Int64, Int64}}} where T","page":"Internals","title":"Hammerhead.fill_symmetric_padding!","text":"fill_symmetric_padding!(padded, original, pad_top, pad_left, original_size)\n\nFill padding regions using symmetric reflection to avoid discontinuities.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_containing_triangle-Tuple{AbstractMatrix, Real, Real}","page":"Internals","title":"Hammerhead.find_containing_triangle","text":"find_containing_triangle(points, query_x, query_y)\n\nFind triangle containing the query point and return barycentric coordinates.\n\nReturns (triangleindices, barycentriccoords) or (nothing, nothing) if outside convex hull.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_local_maxima-Tuple{AbstractMatrix}","page":"Internals","title":"Hammerhead.find_local_maxima","text":"find_local_maxima(correlation_magnitudes) -> Vector{CartesianIndex}\n\nFind all local maxima in correlation plane using robust peak detection. Identifies peaks by finding points that are local maxima in their immediate neighborhood, handling both sharp and broad peaks correctly.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_secondary_peak-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Internals","title":"Hammerhead.find_secondary_peak","text":"find_secondary_peak(correlation_magnitudes, primary_location, primary_value) -> secondary_value\n\nFind the secondary peak in correlation plane, excluding region around primary peak. Uses super-fast approach: find global maximum, then exclude if it's near primary.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_secondary_peak_robust-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Internals","title":"Hammerhead.find_secondary_peak_robust","text":"find_secondary_peak_robust(correlation_magnitudes, primary_location, primary_value) -> secondary_value\n\nFind the secondary peak using local maxima detection for robustness in high shear flows. More computationally expensive but handles closely spaced peaks better.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.generate_interrogation_grid-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}}","page":"Internals","title":"Hammerhead.generate_interrogation_grid","text":"generate_interrogation_grid(image_size, window_size, overlap) -> (grid_x, grid_y)\n\nGenerate grid of interrogation window center positions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.generate_window_1d-Tuple{Hammerhead.SimpleWindow, Int64}","page":"Internals","title":"Hammerhead.generate_window_1d","text":"generate_window_1d(window_function, length) -> window_vector\n\nGenerate 1D window function using DSP.jl implementations for accuracy and performance. Supports both simple and parametric window functions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.get_timer-Tuple{PIVResult}","page":"Internals","title":"Hammerhead.get_timer","text":"get_timer(result::PIVResult) -> TimerOutput\n\nGet the timer data from a PIV result for analysis or integration with other timing systems. Returns a new TimerOutput if no timing data is available.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.interpolate_vectors-Tuple{PIVResult}","page":"Internals","title":"Hammerhead.interpolate_vectors","text":"interpolate_vectors(result::PIVResult; method=:linear_barycentric, \n                   target_status=:interpolated, source_status=:good)\n\nInterpolate vectors in PIV result to replace missing or bad vectors.\n\nArguments\n\nresult::PIVResult: PIV result to interpolate\nmethod::Symbol: Interpolation method (:linear_barycentric, :nearest)\ntarget_status::Symbol: Status to assign to interpolated vectors\nsource_status::Symbol: Only use vectors with this status for interpolation\n\nReturns\n\nModified PIVResult with interpolated vectors\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.is_area_preserving","page":"Internals","title":"Hammerhead.is_area_preserving","text":"is_area_preserving(matrix, tolerance=0.1) -> Bool\n\nCheck if a 2×2 matrix preserves area within tolerance. Area preservation means |det(A)| ≈ 1.\n\nArguments\n\nmatrix::AbstractMatrix - 2×2 transformation matrix\ntolerance::Float64 - Relative tolerance for determinant check\n\nReturns\n\nBool - True if area-preserving within tolerance\n\nExamples\n\nis_area_preserving([1.0 0.1; -0.1 1.0])  # true (rotation + small shear)\nis_area_preserving([2.0 0.0; 0.0 0.5])   # false (scales area by factor of 1.0 but violates uniformity)\nis_area_preserving([1.05 0.0; 0.0 0.95]) # true (small uniform scaling, det ≈ 1.0)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Hammerhead.linear_barycentric_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Internals","title":"Hammerhead.linear_barycentric_interpolation","text":"linear_barycentric_interpolation(points, values, query_points; fallback_method=:nearest)\n\nPerform linear barycentric interpolation for scattered 2D data.\n\nFor each query point, finds the triangle containing it and computes the interpolated value using barycentric coordinates. If a point is outside the convex hull, uses fallback method.\n\nArguments\n\npoints::AbstractMatrix: Nx2 matrix of point coordinates [x y]\nvalues::AbstractVector: N-element vector of values at each point\nquery_points::AbstractMatrix: Mx2 matrix of query point coordinates\nfallback_method::Symbol: Method for points outside convex hull (:nearest, :zero, :nan)\n\nReturns\n\nVector: Interpolated values at query points\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.linear_interpolation_2points-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, Symbol}","page":"Internals","title":"Hammerhead.linear_interpolation_2points","text":"linear_interpolation_2points(points, values, query_points, fallback_method)\n\nLinear interpolation between two points.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.nearest_neighbor_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Internals","title":"Hammerhead.nearest_neighbor_interpolation","text":"nearest_neighbor_interpolation(points, values, query_points)\n\nSimple nearest neighbor interpolation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.pad_to_size-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Int64, Int64}}} where T","page":"Internals","title":"Hammerhead.pad_to_size","text":"pad_to_size(subimg, target_size) -> padded_array\n\nPad a subimage to match target window size using symmetric padding. Uses the 'symmetric' boundary condition which reflects values across the boundary.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.process_chunk!-Union{Tuple{T}, Tuple{Hammerhead.PIVStageCache{T}, Any, Any, Any, Any, Any, PIVStage}, Tuple{Hammerhead.PIVStageCache{T}, Any, Any, Any, Any, Any, PIVStage, Any}} where T","page":"Internals","title":"Hammerhead.process_chunk!","text":"process_chunk!(cache, chunk, grid_x, grid_y, img1, img2, stage, timer=nothing)\n\nProcess a chunk of interrogation windows using the provided cache. Optionally uses timer for detailed performance tracking (thread 1 only).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.run_piv_stage-Union{Tuple{T}, Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage}, Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage, Type{T}}, Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage, Type{T}, Any}} where T","page":"Internals","title":"Hammerhead.run_piv_stage","text":"run_piv_stage(img1, img2, stage, ::Type{T}=Float32) -> PIVResult\n\nPerform PIV analysis for a single stage with parallel processing using ChunkSplitters.jl. Pre-allocates per-thread caches and merges results efficiently.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.validate_affine_transform-Tuple{AbstractMatrix}","page":"Internals","title":"Hammerhead.validate_affine_transform","text":"validate_affine_transform(transform_matrix; tolerance=0.1) -> Bool\n\nValidate an affine transformation matrix for use in iterative deformation. Checks area preservation and other physical constraints.\n\nArguments\n\ntransform_matrix::AbstractMatrix - 2×2 or 3×3 affine transformation matrix\ntolerance::Float64 - Tolerance for area preservation check (default: 0.1)\n\nReturns\n\nBool - True if transform is valid, false otherwise\n\nValidation Criteria\n\nArea preservation: |det(A)| ≈ 1 within tolerance\nNo excessive shear or rotation (condition number check)\nFinite and real values only\n\nExamples\n\n# Valid identity transform\nA = [1.0 0.0; 0.0 1.0]\nvalidate_affine_transform(A)  # true\n\n# Invalid transform (not area-preserving)\nA = [2.0 0.0; 0.0 0.5]  # det = 1.0, but stretches by 2x and compresses by 0.5x\nvalidate_affine_transform(A)  # false\n\n# Valid small deformation\nA = [1.05 0.02; -0.01 0.98]  # Small rotation and stretch\nvalidate_affine_transform(A)  # likely true depending on tolerance\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.PIVStageCache","page":"Internals","title":"Hammerhead.PIVStageCache","text":"PIVStageCache{T, C}\n\nPer-thread computational cache for PIV stage processing. Contains pre-computed resources to avoid repeated allocations and enable thread-safe parallel processing.\n\nFields\n\nwindow::Matrix{T} - Pre-computed window function matrix\ncorrelator::C - Thread-local correlator with FFT plans\nvectors::Vector{PIVVector} - Pre-allocated storage for results\nwindowed_img1::Matrix{T} - Pre-allocated buffer for windowed subimage 1\nwindowed_img2::Matrix{T} - Pre-allocated buffer for windowed subimage 2\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.PIVStageCache-Union{Tuple{PIVStage}, Tuple{T}, Tuple{PIVStage, Type{T}}} where T","page":"Internals","title":"Hammerhead.PIVStageCache","text":"PIVStageCache(stage::PIVStage, ::Type{T}=Float32) -> PIVStageCache{T, CrossCorrelator{T}}\n\nCreate a per-thread computational cache from a PIV stage configuration. Pre-computes the window function matrix and initializes thread-local correlator.\n\n\n\n\n\n","category":"method"}]
}
