var documenterSearchIndex = {"docs":
[{"location":"function_ref/#API-Reference","page":"Function Reference","title":"API Reference","text":"","category":"section"},{"location":"function_ref/","page":"Function Reference","title":"Function Reference","text":"","category":"page"},{"location":"function_ref/#Hammerhead.PIVStages-Tuple{Int64, Int64}","page":"Function Reference","title":"Hammerhead.PIVStages","text":"PIVStages(n_stages::Int, final_size::Int; kwargs...) -> Vector{PIVStage}\n\nCreate a vector of PIVStage configurations for multi-stage PIV analysis with geometric window size progression.\n\nArguments\n\nn_stages::Int - Number of processing stages\nfinal_size::Int - Final window size (smallest stage)\n\nKeyword Arguments\n\nAll PIVStage parameters are supported with either scalar or vector values:\n\noverlap=0.5 - Overlap ratio(s). Can be scalar, tuple, or vector of scalars/tuples\npadding=0 - Padding pixel(s). Can be scalar or vector\ndeformation_iterations=3 - Deformation iteration(s). Can be scalar or vector  \nwindow_function=:rectangular - Window function(s). Can be symbol, tuple (symbol, params...), or vector thereof\ninterpolation_method=:bilinear - Interpolation method(s). Can be scalar symbol or vector of symbols\n\nParameter Handling\n\nScalar values: Applied to all stages\nVector values: Must have length 1 (applied to all) or length n_stages (one per stage)\nOverlap: Scalar values create symmetric overlap (val, val), tuples are used directly\n\nWindow Size Progression\n\nStages use geometric progression: final_size * 2^(n_stages - i) for stage i,  with minimum size constrained to final_size.\n\nExamples\n\n# Basic usage with scalar parameters\nstages = PIVStages(3, 32, overlap=0.5, window_function=:hanning)\n\n# Mixed scalar and vector parameters  \nstages = PIVStages(3, 32, overlap=[0.75, 0.5, 0.25], padding=5)\n\n# Different window functions per stage\nstages = PIVStages(2, 32, window_function=[:rectangular, :hanning])\n\n# Parametric window functions\nstages = PIVStages(3, 32, window_function=[(:kaiser, 5.0), :hanning, (:tukey, 0.3)])\n\n# Asymmetric overlap\nstages = PIVStages(2, 32, overlap=(0.6, 0.4))\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.plot_piv-Tuple{AbstractMatrix, PIVResult}","page":"Function Reference","title":"Hammerhead.plot_piv","text":"plot_piv(background_image, piv_result; kwargs...) -> Figure\n\nCreate an interactive vector plot of PIV results overlaid on a background image. Vectors are colored by their status and scaled for visibility.\n\nArguments\n\nbackground_image::AbstractMatrix - Background image to display\npiv_result::PIVResult - PIV analysis results to visualize\n\nKeyword Arguments\n\nscale::Float64 = 5.0 - Vector scaling factor for visibility\narrow_size::Float64 = 0.02 - Width of vector arrowheads (relative to plot size)\ncolormap_good = :viridis - Colormap for good vectors (by magnitude)\nshow_bad::Bool = true - Whether to show bad/interpolated vectors\ntitle::String = \"PIV Results\" - Plot title\nvector_width::Float64 = 2.0 - Line width for vectors\n\nVector Status Colors\n\n:good - Colored by velocity magnitude using specified colormap\n:interpolated - Orange\n:bad - Red\n:secondary - Yellow\n\nReturns\n\nFigure - CairoMakie figure object that can be displayed or saved\n\nExamples\n\n# Basic usage\nfig = plot_piv(img1, result)\ndisplay(fig)\n\n# Customized visualization\nfig = plot_piv(img1, result, \n                      scale=10.0, \n                      colormap_good=:plasma,\n                      title=\"PIV Analysis - Flow Field\")\n\nRequirements\n\nRequires CairoMakie.jl to be loaded: using CairoMakie\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.run_piv-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}}} where T<:Union{Real, ColorTypes.Gray}","page":"Function Reference","title":"Hammerhead.run_piv","text":"run_piv(img1, img2; correlator=CrossCorrelator, kwargs...) -> PIVResult\nrun_piv(img1, img2, stages::Vector{PIVStage}; correlator=CrossCorrelator, kwargs...) -> Vector{PIVResult}\n\nPerform PIV analysis on image pair with single-stage or multi-stage processing.\n\nArguments\n\nimg1::AbstractArray{<:Real,2} - First image  \nimg2::AbstractArray{<:Real,2} - Second image\nstages::Vector{PIVStage} - Optional multi-stage configuration\n\nKeyword Arguments\n\nwindow_size::Tuple{Int,Int} - Window size for single-stage (default: (64,64))\noverlap::Tuple{Float64,Float64} - Overlap ratios (default: (0.5,0.5))\n\nReturns\n\nPIVResult for single-stage processing\nVector{PIVResult} for multi-stage processing\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.PIVResult","page":"Function Reference","title":"Hammerhead.PIVResult","text":"PIVResult\n\nContainer for complete PIV analysis results with property forwarding.\n\nFields\n\nvectors::StructArray{PIVVector} - Vector field data\nmetadata::Dict{String, Any} - Processing parameters and run information  \nauxiliary::Dict{String, Any} - Additional data (correlation planes, secondary peaks, etc.)\n\nProperty Forwarding\n\nProvides direct access to vector field properties:\n\nresult.x → result.vectors.x\nresult.u → result.vectors.u\netc.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.PIVStage","page":"Function Reference","title":"Hammerhead.PIVStage","text":"PIVStage{W<:WindowFunction, I<:InterpolationMethod}\n\nConfiguration for individual processing stage in multi-stage PIV analysis.\n\nFields\n\nwindow_size::Tuple{Int, Int} - Window dimensions (height, width)\noverlap::Tuple{Float64, Float64} - Overlap ratios (vertical, horizontal) ∈ [0, 1)\npadding::Int - Window padding pixels\ndeformation_iterations::Int - Number of deformation iterations\nwindow_function::W - Windowing function type\ninterpolation_method::I - Interpolation method type\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.PIVVector","page":"Function Reference","title":"Hammerhead.PIVVector","text":"PIVVector\n\nIndividual vector data point containing position, displacement, and quality metrics.\n\nFields\n\nx::Float64 - Grid x-coordinate\ny::Float64 - Grid y-coordinate  \nu::Float64 - Displacement in x-direction\nv::Float64 - Displacement in y-direction\nstatus::Symbol - Vector status (:good, :interpolated, :bad, :secondary)\npeak_ratio::Float64 - Primary/secondary peak ratio\ncorrelation_moment::Float64 - Correlation peak sharpness metric\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Validators","page":"Function Reference","title":"Validators","text":"","category":"section"},{"location":"function_ref/","page":"Function Reference","title":"Function Reference","text":"Convenient aliases for vector validation methods.","category":"page"},{"location":"function_ref/#Hammerhead.Validators","page":"Function Reference","title":"Hammerhead.Validators","text":"Validators\n\nSub-module providing clean access to PIV vector validation types.\n\nUsage\n\nusing Hammerhead.Validators\n\n# Clean validator names without \"Validator\" suffix\nvalidation = (PeakRatio(1.2), LocalMedian(window_size=3, threshold=2.0))\n\n\n\n\n\n","category":"module"},{"location":"function_ref/#Hammerhead.Validators.CorrelationMoment","page":"Function Reference","title":"Hammerhead.Validators.CorrelationMoment","text":"CorrelationMoment(threshold::Float64)\n\nValidates vectors based on correlation moment (peak sharpness). Alias for CorrelationMomentValidator.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.Validators.LocalMedian","page":"Function Reference","title":"Hammerhead.Validators.LocalMedian","text":"LocalMedian(window_size::Int, threshold::Float64)\n\nValidates vectors against median of local neighborhood. Alias for LocalMedianValidator.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.Validators.NormalizedResidual","page":"Function Reference","title":"Hammerhead.Validators.NormalizedResidual","text":"NormalizedResidual(window_size::Int, threshold::Float64)\n\nValidates vectors using normalized residual against local interpolated field. Alias for NormalizedResidualValidator.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.Validators.PeakRatio","page":"Function Reference","title":"Hammerhead.Validators.PeakRatio","text":"PeakRatio(threshold::Float64)\n\nValidates vectors based on correlation peak ratio (primary/secondary peak). Alias for PeakRatioValidator.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.Validators.VelocityMagnitude","page":"Function Reference","title":"Hammerhead.Validators.VelocityMagnitude","text":"VelocityMagnitude(min::Float64, max::Float64)\n\nValidates vectors based on displacement magnitude bounds. Alias for VelocityMagnitudeValidator.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Synthetic-Data","page":"Function Reference","title":"Synthetic Data","text":"","category":"section"},{"location":"function_ref/#Hammerhead.SyntheticData","page":"Function Reference","title":"Hammerhead.SyntheticData","text":"SyntheticData\n\nSubmodule for generating synthetic PIV test data with proper particle-based image generation. Provides accurate ground truth by directly displacing particle positions rather than using bilinear interpolation warping. Includes realistic effects of out-of-plane motion and laser sheet intensity profiles.\n\n\n\n\n\n","category":"module"},{"location":"function_ref/#Hammerhead.SyntheticData.displace_particles!","page":"Function Reference","title":"Hammerhead.SyntheticData.displace_particles!","text":"displace_particles!(particles::ParticleField3D, velocity_function, dt::Real, t::Real=0.0)\n\nDisplace particles according to the velocity function for time step dt. Modifies particles in-place.\n\nArguments\n\nparticles: ParticleField3D to modify\nvelocity_function: Function with signature (x, y, z, t) -> (u, v, w)\ndt: Time step\nt: Current time (default 0.0)\n\n\n\n\n\n","category":"function"},{"location":"function_ref/#Hammerhead.SyntheticData.generate_gaussian_particle!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Real, Real}, Real}, Tuple{AbstractMatrix{T}, Tuple{Real, Real}, Real, Real}} where T<:Real","page":"Function Reference","title":"Hammerhead.SyntheticData.generate_gaussian_particle!","text":"generate_gaussian_particle!(image, center, diameter, intensity=1.0)\n\nAdd a Gaussian particle to an image at the specified center position.\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.SyntheticData.generate_particle_field-Tuple{Tuple{Int64, Int64}, Real}","page":"Function Reference","title":"Hammerhead.SyntheticData.generate_particle_field","text":"generate_particle_field(image_size, particle_density; kwargs...) -> ParticleField3D\n\nGenerate a random 3D particle field for synthetic PIV images.\n\nArguments\n\nimage_size::Tuple{Int,Int}: Size of the image (height, width)\nparticle_density::Real: Average particles per pixel\n\nKeywords\n\nz_range::Tuple{Real,Real}=(-5.0, 5.0): Range of z-positions (laser sheet typically at z=0)\ndiameter_mean::Real=3.0: Mean particle diameter in pixels\ndiameter_std::Real=0.5: Standard deviation of particle diameter\nintensity_mean::Real=1.0: Mean particle intensity\nintensity_std::Real=0.2: Standard deviation of particle intensity\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.SyntheticData.generate_synthetic_piv_pair-Tuple{Any, Tuple{Int64, Int64}, Real}","page":"Function Reference","title":"Hammerhead.SyntheticData.generate_synthetic_piv_pair","text":"generate_synthetic_piv_pair(velocity_function, image_size, dt; kwargs...) -> (img1, img2, particles1, particles2)\n\nGenerate a synthetic PIV image pair with known ground truth displacement. Includes realistic effects of out-of-plane motion and laser sheet illumination.\n\nArguments\n\nvelocity_function: Function with signature (x, y, z, t) -> (u, v, w)\nimage_size::Tuple{Int,Int}: Size of images (height, width)  \ndt::Real: Time step between images\n\nKeywords\n\nparticle_density::Real=0.05: Particles per pixel\nlaser_sheet::LaserSheet=GaussianLaserSheet(0.0, 2.0, 1.0): Laser sheet profile\nbackground_noise::Real=0.01: Background noise level\nz_range::Tuple{Real,Real}=(-5.0, 5.0): Range of particle z-positions\nt0::Real=0.0: Initial time\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\nAdditional keywords passed to generate_particle_field\n\nReturns\n\nimg1, img2: The two synthetic PIV images\nparticles1, particles2: The 3D particle fields for ground truth analysis\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.SyntheticData.linear_flow-NTuple{7, Any}","page":"Function Reference","title":"Hammerhead.SyntheticData.linear_flow","text":"linear_flow(u₀, v₀, w₀, ∂u∂x, ∂u∂y, ∂v∂x, ∂v∂y) -> velocity_function\n\nCreate a linear velocity field function.\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.SyntheticData.render_particle_image-Tuple{Hammerhead.SyntheticData.ParticleField3D, Tuple{Int64, Int64}, Hammerhead.SyntheticData.LaserSheet}","page":"Function Reference","title":"Hammerhead.SyntheticData.render_particle_image","text":"render_particle_image(particles::ParticleField3D, image_size, laser::LaserSheet; kwargs...) -> Matrix\n\nRender a 3D ParticleField into an image with laser sheet intensity modulation.\n\nKeywords\n\nbackground_noise::Real=0.01: Background noise level\nintensity_threshold::Real=0.01: Minimum laser intensity for particle visibility\nrng::AbstractRNG=Random.GLOBAL_RNG: Random number generator\n\n\n\n\n\n","category":"method"},{"location":"function_ref/#Hammerhead.SyntheticData.shear_flow","page":"Function Reference","title":"Hammerhead.SyntheticData.shear_flow","text":"shear_flow(shear_rate, w₀=0.0) -> velocity_function\n\nCreate a simple shear velocity field function.\n\n\n\n\n\n","category":"function"},{"location":"function_ref/#Hammerhead.SyntheticData.vortex_flow","page":"Function Reference","title":"Hammerhead.SyntheticData.vortex_flow","text":"vortex_flow(center_x, center_y, strength, w₀=0.0) -> velocity_function\n\nCreate a circular vortex velocity field function.\n\n\n\n\n\n","category":"function"},{"location":"function_ref/#Hammerhead.SyntheticData.GaussianLaserSheet","page":"Function Reference","title":"Hammerhead.SyntheticData.GaussianLaserSheet","text":"GaussianLaserSheet(z_center, thickness, peak_intensity)\n\nGaussian laser sheet profile with specified center, thickness, and peak intensity. Intensity falls off as exp(-(z-z_center)²/(2σ²)) where σ = thickness/4.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.SyntheticData.LaserSheet","page":"Function Reference","title":"Hammerhead.SyntheticData.LaserSheet","text":"LaserSheet\n\nAbstract type for laser sheet intensity profiles.\n\n\n\n\n\n","category":"type"},{"location":"function_ref/#Hammerhead.SyntheticData.ParticleField3D","page":"Function Reference","title":"Hammerhead.SyntheticData.ParticleField3D","text":"ParticleField3D\n\nRepresents a collection of particles with 3D positions and properties. Includes z-coordinate for out-of-plane motion effects.\n\n\n\n\n\n","category":"type"},{"location":"#Hammerhead.jl","page":"Home","title":"Hammerhead.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modern, high-performance Julia package for Particle Image Velocimetry (PIV) analysis, designed to provide capabilities on par with established tools while leveraging Julia's performance and ecosystem.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl provides a 2D PIV analysis pipeline for experimental fluid dynamics. The package processes image pairs to extract velocity vector fields, supporting both simple single-stage analysis and sophisticated multi-stage processing (in-progress) for improved accuracy in challenging flow conditions.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"High Performance: Type-stable implementations with optimized FFT-based correlation and parallel processing\nParallel Processing: Thread-safe multi-core processing using ChunkSplitters.jl for optimal work distribution\nMemory Efficient: Per-thread caches with pre-computed window functions and pre-allocated buffers\nFlexible Configuration: Multi-stage processing with configurable window sizes, overlap ratios, and windowing functions\nQuality Assessment: Built-in peak ratio and correlation moment metrics for vector validation\nModern Architecture: Clean APIs with property forwarding and symbol-based configuration\nComprehensive Windowing: Support for all DSP.jl windowing functions (Hanning, Hamming, Blackman, Kaiser, etc.)\nRobust Processing: Boundary handling with symmetric padding and graceful error recovery\nDetailed Timing: Comprehensive performance instrumentation with TimerOutputs.jl integration","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Basic-PIV-Analysis","page":"Home","title":"Basic PIV Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Hammerhead\n\n# Load your image pair\nimg1 = load(\"image1.tif\")\nimg2 = load(\"image2.tif\")\n\n# Perform single-stage PIV analysis\nresult = run_piv(img1, img2, window_size=(64, 64), overlap=(0.5, 0.5))\n\n# Access results with clean API\ndisplacement_x = result.u  # X-direction displacements\ndisplacement_y = result.v  # Y-direction displacements\npositions_x = result.x     # Grid x-coordinates\npositions_y = result.y     # Grid y-coordinates\nquality = result.peak_ratio # Quality metrics","category":"page"},{"location":"#Multi-Stage-Processing","page":"Home","title":"Multi-Stage Processing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Create multi-stage configuration for improved accuracy\nstages = PIVStages(3, 32,  # 3 stages ending at 32×32 windows\n                   overlap=0.5,\n                   window_function=:hanning)\n\n# Perform multi-stage analysis\nresults = run_piv(img1, img2, stages)\n\n# Access final stage results\nfinal_result = results[end]","category":"page"},{"location":"#Advanced-Configuration","page":"Home","title":"Advanced Configuration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Custom stage configuration with different parameters\nstage1 = PIVStage((128, 128), overlap=(0.75, 0.75), window_function=:rectangular)\nstage2 = PIVStage((64, 64), overlap=(0.5, 0.5), window_function=:hanning)\nstage3 = PIVStage((32, 32), overlap=(0.25, 0.25), window_function=(:kaiser, 5.0))\n\nresults = run_piv(img1, img2, [stage1, stage2, stage3])","category":"page"},{"location":"#Performance-Timing","page":"Home","title":"Performance Timing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl automatically instruments all PIV operations with detailed timing data:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Run PIV analysis (timing is automatic)\nresult = run_piv(img1, img2, window_size=(64, 64))\n\n# Access timing information\nusing TimerOutputs  # Need to import for print_timer\ntimer = get_timer(result)\nprint_timer(timer)  # Prints detailed timing breakdown\n\n# For multi-stage analysis, timing is in the first result\nresults = run_piv(img1, img2, stages)\ntimer = get_timer(results[1])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Timing data includes hierarchical breakdown of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"FFT operations (forward, inverse, setup)\nCross-correlation computation  \nPeak analysis and subpixel refinement\nParallel window processing with thread-level detail\nGrid generation and cache allocation\nResult assembly and merging","category":"page"},{"location":"#Core-Data-Structures","page":"Home","title":"Core Data Structures","text":"","category":"section"},{"location":"#PIVVector","page":"Home","title":"PIVVector","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Individual vector measurement containing position, displacement, and quality metrics.","category":"page"},{"location":"#PIVResult","page":"Home","title":"PIVResult","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Container for complete analysis results with property forwarding for ergonomic access:","category":"page"},{"location":"","page":"Home","title":"Home","text":"result.x, result.y - Grid positions\nresult.u, result.v - Displacement components  \nresult.peak_ratio - Primary/secondary peak ratio\nresult.correlation_moment - Correlation peak sharpness","category":"page"},{"location":"#PIVStage","page":"Home","title":"PIVStage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Configuration for individual processing stages with type-safe parameters:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Window size and overlap ratios\nWindowing functions (rectangular, Hanning, Hamming, Blackman, Kaiser, etc.)\nInterpolation methods\nDeformation iterations","category":"page"},{"location":"#Windowing-Functions","page":"Home","title":"Windowing Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl leverages DSP.jl for mathematically correct windowing functions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Simple windows\nPIVStage((64, 64), window_function=:hanning)\nPIVStage((64, 64), window_function=:blackman)\n\n# Parametric windows  \nPIVStage((64, 64), window_function=(:kaiser, 5.0))\nPIVStage((64, 64), window_function=(:tukey, 0.3))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supported functions include: :rectangular, :hanning, :hamming, :blackman, :bartlett, :cosine, :lanczos, :triang, :kaiser, :tukey, :gaussian.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parallel Processing: Automatic multi-threaded execution using ChunkSplitters.jl for optimal CPU utilization\nMemory Efficiency: Per-thread caches eliminate repeated allocations and window function computations\nOptimized Algorithms: Fast FFT-based correlation with pre-allocated buffers and type-stable implementations\nScalable Design: Efficient processing of large datasets with minimal memory overhead\nPerformance Monitoring: Built-in timing instrumentation for performance analysis and optimization","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hammerhead.jl delivers excellent performance with near-linear scaling across available CPU cores, making it suitable for both interactive analysis and high-throughput batch processing.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/stillyslalom/Hammerhead.jl\")","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"internals/#Hammerhead.analyze_correlation_plane","page":"Internals","title":"Hammerhead.analyze_correlation_plane","text":"analyze_correlation_plane(correlation_plane) -> (displacement, peak_ratio, correlation_moment)\n\nAnalyze correlation plane to extract displacement and quality metrics at PIV stage level. This allows the same analysis to be applied to results from different correlation algorithms.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Hammerhead.apply_cached_window!-Union{Tuple{T2}, Tuple{T1}, Tuple{Hammerhead.PIVStageCache{T1}, AbstractArray{T2}, AbstractArray{T2}}} where {T1, T2}","page":"Internals","title":"Hammerhead.apply_cached_window!","text":"apply_cached_window!(cache, subimg1, subimg2) -> (windowed1, windowed2)\n\nApply pre-computed window function to both subimages using pre-allocated buffers. Returns references to the cached windowed image buffers for efficient memory usage.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.apply_local_validator!-Tuple{StructArrays.StructArray{PIVVector}, Hammerhead.LocalValidator}","page":"Internals","title":"Hammerhead.apply_local_validator!","text":"apply_local_validator!(vectors::StructArray{PIVVector}, validator::LocalValidator)\n\nApply single local validator to vector field.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.apply_local_validators!-Tuple{StructArrays.StructArray{PIVVector}, Vector{<:Hammerhead.LocalValidator}}","page":"Internals","title":"Hammerhead.apply_local_validators!","text":"apply_local_validators!(vectors::StructArray{PIVVector}, validators::Vector{<:LocalValidator})\n\nBatch local validators into single loop for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.apply_vector_replacement!-Tuple{PIVResult}","page":"Internals","title":"Hammerhead.apply_vector_replacement!","text":"apply_vector_replacement!(result::PIVResult; method=:iterative_median)\n\nApply vector replacement (hole filling) to PIV result. Uses robust iterative median approach by default for inter-stage stability.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.apply_window!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T}}} where T","page":"Internals","title":"Hammerhead.apply_window!","text":"apply_window!(subimage, window) -> windowed_subimage\n\nApply windowing array to subimage to reduce spectral leakage in correlation analysis.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.barycentric_coordinates-NTuple{4, AbstractVector}","page":"Internals","title":"Hammerhead.barycentric_coordinates","text":"barycentric_coordinates(p1, p2, p3, query)\n\nCompute barycentric coordinates of query point with respect to triangle p1-p2-p3.\n\nReturns (λ1, λ2, λ3) such that query = λ1p1 + λ2p2 + λ3*p3 and λ1 + λ2 + λ3 = 1.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.build_window-Tuple{Any, Hammerhead.WindowFunction}","page":"Internals","title":"Hammerhead.build_window","text":"build_window(size, window_function) -> window\n\nBuild a 2D window function for the given size using the specified window function type.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.calculate_correlation_moment-Tuple{AbstractMatrix, CartesianIndex}","page":"Internals","title":"Hammerhead.calculate_correlation_moment","text":"calculate_correlation_moment(correlation_magnitudes, peak_location) -> moment\n\nCalculate normalized second moment of correlation peak as sharpness measure.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.calculate_quality_metrics-Union{Tuple{T}, Tuple{AbstractMatrix{T}, CartesianIndex, Real}} where T","page":"Internals","title":"Hammerhead.calculate_quality_metrics","text":"calculate_quality_metrics(correlation_plane, peak_location, peak_value; robust=false) -> (peak_ratio, correlation_moment)\n\nCalculate quality metrics for PIV correlation analysis.\n\nArguments\n\ncorrelation_plane - Complex correlation result matrix\npeak_location - CartesianIndex of primary peak location\npeak_value - Magnitude of primary peak\nrobust=false - Use robust local maxima method for secondary peak detection\n\nReturns\n\npeak_ratio::Float64 - Ratio of primary peak to secondary peak (higher is better)\ncorrelation_moment::Float64 - Normalized correlation moment (measure of peak sharpness)\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.classify_hole-Tuple{Vector{CartesianIndex{2}}, NTuple{4, Int64}}","page":"Internals","title":"Hammerhead.classify_hole","text":"classify_hole(indices, bounding_box) -> Symbol\n\nClassify hole region based on size and shape characteristics.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.detect_garbage_regions-Tuple{StructArrays.StructArray{PIVVector}}","page":"Internals","title":"Hammerhead.detect_garbage_regions","text":"detect_garbage_regions(vectors::StructArray{PIVVector}) -> BitMatrix\n\nDetect large regions of bad vectors that should be abandoned rather than filled. Uses morphological operations to identify regions too sparse for reliable interpolation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.detect_holes-Tuple{StructArrays.StructArray{PIVVector}}","page":"Internals","title":"Hammerhead.detect_holes","text":"detect_holes(vectors::StructArray{PIVVector}) -> Vector{HoleRegion}\n\nDetect connected components of bad vectors using ImageMorphology.jl.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.fill_symmetric_padding!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Int64, Int64, Tuple{Int64, Int64}}} where T","page":"Internals","title":"Hammerhead.fill_symmetric_padding!","text":"fill_symmetric_padding!(padded, original, pad_top, pad_left, original_size)\n\nFill padding regions using symmetric reflection to avoid discontinuities.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_containing_triangle-Tuple{AbstractMatrix, Real, Real}","page":"Internals","title":"Hammerhead.find_containing_triangle","text":"find_containing_triangle(points, query_x, query_y)\n\nFind triangle containing the query point and return barycentric coordinates.\n\nReturns (triangleindices, barycentriccoords) or (nothing, nothing) if outside convex hull.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_local_maxima-Tuple{AbstractMatrix}","page":"Internals","title":"Hammerhead.find_local_maxima","text":"find_local_maxima(correlation_magnitudes) -> Vector{CartesianIndex}\n\nFind all local maxima in correlation plane using robust peak detection. Identifies peaks by finding points that are local maxima in their immediate neighborhood, handling both sharp and broad peaks correctly.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_secondary_peak-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Internals","title":"Hammerhead.find_secondary_peak","text":"find_secondary_peak(correlation_magnitudes, primary_location, primary_value) -> secondary_value\n\nFind the secondary peak in correlation plane, excluding region around primary peak. Uses super-fast approach: find global maximum, then exclude if it's near primary.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.find_secondary_peak_robust-Tuple{AbstractMatrix, CartesianIndex, Real}","page":"Internals","title":"Hammerhead.find_secondary_peak_robust","text":"find_secondary_peak_robust(correlation_magnitudes, primary_location, primary_value) -> secondary_value\n\nFind the secondary peak using local maxima detection for robustness in high shear flows. More computationally expensive but handles closely spaced peaks better.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.generate_interrogation_grid-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Float64, Float64}}","page":"Internals","title":"Hammerhead.generate_interrogation_grid","text":"generate_interrogation_grid(image_size, window_size, overlap) -> (grid_x, grid_y)\n\nGenerate grid of interrogation window center positions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.generate_window_1d-Tuple{Hammerhead.SimpleWindow, Int64}","page":"Internals","title":"Hammerhead.generate_window_1d","text":"generate_window_1d(window_function, length) -> window_vector\n\nGenerate 1D window function using DSP.jl implementations for accuracy and performance. Supports both simple and parametric window functions.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.get_timer-Tuple{PIVResult}","page":"Internals","title":"Hammerhead.get_timer","text":"get_timer(result::PIVResult) -> TimerOutput\n\nGet the timer data from a PIV result for analysis or integration with other timing systems. Returns a new TimerOutput if no timing data is available.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.get_valid_mask-Tuple{StructArrays.StructArray{PIVVector}}","page":"Internals","title":"Hammerhead.get_valid_mask","text":"get_valid_mask(vectors::StructArray{PIVVector}) -> BitMatrix\n\nCreate mask of currently valid vectors for neighborhood operations.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.interpolate_vectors-Tuple{PIVResult}","page":"Internals","title":"Hammerhead.interpolate_vectors","text":"interpolate_vectors(result::PIVResult; method=:linear_barycentric, \n                   target_status=:interpolated, source_status=:good)\n\nInterpolate vectors in PIV result to replace missing or bad vectors.\n\nArguments\n\nresult::PIVResult: PIV result to interpolate\nmethod::Symbol: Interpolation method (:linear_barycentric, :nearest)\ntarget_status::Symbol: Status to assign to interpolated vectors\nsource_status::Symbol: Only use vectors with this status for interpolation\n\nReturns\n\nModified PIVResult with interpolated vectors\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.is_area_preserving","page":"Internals","title":"Hammerhead.is_area_preserving","text":"is_area_preserving(matrix, tolerance=0.1) -> Bool\n\nCheck if a 2×2 matrix preserves area within tolerance. Area preservation means |det(A)| ≈ 1.\n\nArguments\n\nmatrix::AbstractMatrix - 2×2 transformation matrix\ntolerance::Float64 - Relative tolerance for determinant check\n\nReturns\n\nBool - True if area-preserving within tolerance\n\nExamples\n\nis_area_preserving([1.0 0.1; -0.1 1.0])  # true (rotation + small shear)\nis_area_preserving([2.0 0.0; 0.0 0.5])   # false (scales area by factor of 1.0 but violates uniformity)\nis_area_preserving([1.05 0.0; 0.0 0.95]) # true (small uniform scaling, det ≈ 1.0)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Hammerhead.is_valid-Tuple{PIVVector, Hammerhead.PeakRatioValidator}","page":"Internals","title":"Hammerhead.is_valid","text":"is_valid(vector::PIVVector, validator::LocalValidator) -> Bool\n\nTest if individual vector passes validation criteria.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.linear_barycentric_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Internals","title":"Hammerhead.linear_barycentric_interpolation","text":"linear_barycentric_interpolation(points, values, query_points; fallback_method=:nearest)\n\nPerform linear barycentric interpolation for scattered 2D data.\n\nFor each query point, finds the triangle containing it and computes the interpolated value using barycentric coordinates. If a point is outside the convex hull, uses fallback method.\n\nArguments\n\npoints::AbstractMatrix: Nx2 matrix of point coordinates [x y]\nvalues::AbstractVector: N-element vector of values at each point\nquery_points::AbstractMatrix: Mx2 matrix of query point coordinates\nfallback_method::Symbol: Method for points outside convex hull (:nearest, :zero, :nan)\n\nReturns\n\nVector: Interpolated values at query points\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.linear_interpolation_2points-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, Symbol}","page":"Internals","title":"Hammerhead.linear_interpolation_2points","text":"linear_interpolation_2points(points, values, query_points, fallback_method)\n\nLinear interpolation between two points.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.nearest_neighbor_interpolation-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Internals","title":"Hammerhead.nearest_neighbor_interpolation","text":"nearest_neighbor_interpolation(points, values, query_points)\n\nSimple nearest neighbor interpolation.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.pad_to_size-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Tuple{Int64, Int64}}} where T","page":"Internals","title":"Hammerhead.pad_to_size","text":"pad_to_size(subimg, target_size) -> padded_array\n\nPad a subimage to match target window size using symmetric padding. Uses the 'symmetric' boundary condition which reflects values across the boundary.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.parse_validation_pipeline-Tuple{Tuple}","page":"Internals","title":"Hammerhead.parse_validation_pipeline","text":"parse_validation_pipeline(pipeline::Tuple) -> Tuple of PIVValidators\n\nConvert validation pipeline tuple to validator objects. Uses tuple to distinguish from multi-stage PIV vector parameters.\n\nExamples\n\n# Object syntax\npipeline = (PeakRatioValidator(1.2), LocalMedianValidator(3, 2.0))\n\n# Pair syntax  \npipeline = (:peak_ratio => 1.2, :local_median => (window_size=3, threshold=2.0))\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.parse_validator-Tuple{Hammerhead.PIVValidator}","page":"Internals","title":"Hammerhead.parse_validator","text":"parse_validator(spec) -> PIVValidator\n\nConvert user specification to validator object. Supports both object syntax and pair syntax.\n\nExamples\n\n# Object syntax\nparse_validator(PeakRatioValidator(1.2))\n\n# Pair syntax\nparse_validator(:peak_ratio => 1.2)\nparse_validator(:local_median => (window_size=3, threshold=2.0))\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.process_chunk!-Union{Tuple{T}, Tuple{Hammerhead.PIVStageCache{T}, Any, Any, Any, Any, Any, PIVStage}, Tuple{Hammerhead.PIVStageCache{T}, Any, Any, Any, Any, Any, PIVStage, Any}} where T","page":"Internals","title":"Hammerhead.process_chunk!","text":"process_chunk!(cache, chunk, grid_x, grid_y, img1, img2, stage, timer=nothing)\n\nProcess a chunk of interrogation windows using the provided cache. Optionally uses timer for detailed performance tracking (thread 1 only).\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.replace_vectors!-Tuple{StructArrays.StructArray{PIVVector}, Hammerhead.HoleRegion, Hammerhead.DelaunayBarycentric}","page":"Internals","title":"Hammerhead.replace_vectors!","text":"replace_vectors!(vectors::StructArray{PIVVector}, hole::HoleRegion, method::DelaunayBarycentric)\n\nReplace large/irregular holes using Delaunay triangulation with barycentric interpolation. Uses morphological operations to efficiently find boundary good pixels.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.replace_vectors!-Tuple{StructArrays.StructArray{PIVVector}, Hammerhead.HoleRegion, Hammerhead.InverseDistanceWeighted}","page":"Internals","title":"Hammerhead.replace_vectors!","text":"replace_vectors!(vectors::StructArray{PIVVector}, hole::HoleRegion, method::InverseDistanceWeighted)\n\nReplace small cluster holes using inverse distance weighted interpolation. Efficient method for clusters ≤2×2.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.replace_vectors!-Tuple{StructArrays.StructArray{PIVVector}, Hammerhead.HoleRegion, Hammerhead.VectorMedian}","page":"Internals","title":"Hammerhead.replace_vectors!","text":"replace_vectors!(vectors::StructArray{PIVVector}, hole::HoleRegion, method::VectorMedian)\n\nReplace isolated holes using median of neighboring good vectors. Fast method for single bad vectors.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.replace_vectors!-Tuple{StructArrays.StructArray{PIVVector}, Vector{Hammerhead.HoleRegion}, Hammerhead.IterativeMedian}","page":"Internals","title":"Hammerhead.replace_vectors!","text":"replace_vectors!(vectors::StructArray{PIVVector}, holes::Vector{HoleRegion}, method::IterativeMedian)\n\nIteratively fill all holes using robust median-based interpolation. Processes all holes together with multiple passes for stable convergence.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.run_piv_stage-Union{Tuple{T}, Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage}, Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage, Type{T}}, Tuple{AbstractMatrix{<:Real}, AbstractMatrix{<:Real}, PIVStage, Type{T}, Any}} where T","page":"Internals","title":"Hammerhead.run_piv_stage","text":"run_piv_stage(img1, img2, stage, ::Type{T}=Float32) -> PIVResult\n\nPerform PIV analysis for a single stage with parallel processing using ChunkSplitters.jl. Pre-allocates per-thread caches and merges results efficiently.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.update_valid_mask!-Tuple{BitMatrix, StructArrays.StructArray{PIVVector}}","page":"Internals","title":"Hammerhead.update_valid_mask!","text":"update_valid_mask!(mask::BitMatrix, vectors::StructArray{PIVVector})\n\nUpdate validity mask after validation step.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.validate_affine_transform-Tuple{AbstractMatrix}","page":"Internals","title":"Hammerhead.validate_affine_transform","text":"validate_affine_transform(transform_matrix; tolerance=0.1) -> Bool\n\nValidate an affine transformation matrix for use in iterative deformation. Checks area preservation and other physical constraints.\n\nArguments\n\ntransform_matrix::AbstractMatrix - 2×2 or 3×3 affine transformation matrix\ntolerance::Float64 - Tolerance for area preservation check (default: 0.1)\n\nReturns\n\nBool - True if transform is valid, false otherwise\n\nValidation Criteria\n\nArea preservation: |det(A)| ≈ 1 within tolerance\nNo excessive shear or rotation (condition number check)\nFinite and real values only\n\nExamples\n\n# Valid identity transform\nA = [1.0 0.0; 0.0 1.0]\nvalidate_affine_transform(A)  # true\n\n# Invalid transform (not area-preserving)\nA = [2.0 0.0; 0.0 0.5]  # det = 1.0, but stretches by 2x and compresses by 0.5x\nvalidate_affine_transform(A)  # false\n\n# Valid small deformation\nA = [1.05 0.02; -0.01 0.98]  # Small rotation and stretch\nvalidate_affine_transform(A)  # likely true depending on tolerance\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.validate_vectors!-Tuple{PIVResult, Tuple}","page":"Internals","title":"Hammerhead.validate_vectors!","text":"validate_vectors!(result::PIVResult, validation_pipeline::Tuple)\n\nApply validation pipeline to PIV result, optimizing for performance. Local validators are batched together, neighborhood validators applied separately.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.AbstractReplacementMethod","page":"Internals","title":"Hammerhead.AbstractReplacementMethod","text":"AbstractReplacementMethod\n\nAbstract base type for vector replacement methods.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.CorrelationMomentValidator","page":"Internals","title":"Hammerhead.CorrelationMomentValidator","text":"CorrelationMomentValidator(threshold::Float64)\n\nValidates vectors based on correlation moment (peak sharpness). Higher moments indicate sharper, more reliable peaks.\n\nArguments\n\nthreshold: Minimum acceptable correlation moment (typically 0.1-0.5)\n\nExample\n\nvalidator = CorrelationMomentValidator(0.2)  # Require moment ≥ 0.2\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.DelaunayBarycentric","page":"Internals","title":"Hammerhead.DelaunayBarycentric","text":"DelaunayBarycentric <: AbstractReplacementMethod\n\nDelaunay triangulation with barycentric interpolation for large/irregular holes.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.HoleRegion","page":"Internals","title":"Hammerhead.HoleRegion","text":"HoleRegion\n\nRepresents a region of bad/missing vectors that needs replacement.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.InverseDistanceWeighted","page":"Internals","title":"Hammerhead.InverseDistanceWeighted","text":"InverseDistanceWeighted <: AbstractReplacementMethod\n\nInverse distance weighted interpolation for small clusters (≤2×2).\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.IterativeMedian","page":"Internals","title":"Hammerhead.IterativeMedian","text":"IterativeMedian <: AbstractReplacementMethod\n\nIterative median-filling approach for robust inter-stage interpolation. Based on commercial PIV practices for maximum stability.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.LocalMedianValidator","page":"Internals","title":"Hammerhead.LocalMedianValidator","text":"LocalMedianValidator(window_size::Int, threshold::Float64)\n\nValidates vectors against median of local neighborhood. Vectors deviating more than threshold standard deviations from local median are marked as outliers.\n\nArguments\n\nwindow_size: Radius of neighborhood window (e.g., 3 = 7×7 window)\nthreshold: Deviation threshold in standard deviations (typically 2-3)\n\nExample\n\nvalidator = LocalMedianValidator(3, 2.0)  # 7×7 window, 2σ threshold\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.LocalValidator","page":"Internals","title":"Hammerhead.LocalValidator","text":"Validators that examine individual vector properties without considering neighbors. These can be efficiently batched together in a single loop.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.NeighborhoodValidator","page":"Internals","title":"Hammerhead.NeighborhoodValidator","text":"Validators that examine vectors relative to their spatial neighbors. These require knowledge of surrounding valid vectors and are applied separately.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.NormalizedResidualValidator","page":"Internals","title":"Hammerhead.NormalizedResidualValidator","text":"NormalizedResidualValidator(window_size::Int, threshold::Float64)\n\nValidates vectors using normalized residual against local interpolated field. More sophisticated than median test, accounts for local flow gradients.\n\nArguments\n\nwindow_size: Radius of neighborhood for interpolation\nthreshold: Normalized residual threshold (typically 2-4)\n\nExample\n\nvalidator = NormalizedResidualValidator(5, 3.0)  # 11×11 window, 3σ threshold\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.PIVStageCache","page":"Internals","title":"Hammerhead.PIVStageCache","text":"PIVStageCache{T, C}\n\nPer-thread computational cache for PIV stage processing. Contains pre-computed resources to avoid repeated allocations and enable thread-safe parallel processing.\n\nFields\n\nwindow::Matrix{T} - Pre-computed window function matrix\ncorrelator::C - Thread-local correlator with FFT plans\nvectors::Vector{PIVVector} - Pre-allocated storage for results\nwindowed_img1::Matrix{T} - Pre-allocated buffer for windowed subimage 1\nwindowed_img2::Matrix{T} - Pre-allocated buffer for windowed subimage 2\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.PIVStageCache-Union{Tuple{PIVStage}, Tuple{T}, Tuple{PIVStage, Type{T}}} where T","page":"Internals","title":"Hammerhead.PIVStageCache","text":"PIVStageCache(stage::PIVStage, ::Type{T}=Float32) -> PIVStageCache{T, CrossCorrelator{T}}\n\nCreate a per-thread computational cache from a PIV stage configuration. Pre-computes the window function matrix and initializes thread-local correlator.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Hammerhead.PIVValidator","page":"Internals","title":"Hammerhead.PIVValidator","text":"Abstract base type for PIV vector validation algorithms.\n\nValidators are applied sequentially to filter out unreliable displacement vectors. Two main categories exist:\n\nLocalValidator: Tests individual vectors against thresholds (fast)\nNeighborhoodValidator: Tests vectors against local neighborhood statistics (slower)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.PeakRatioValidator","page":"Internals","title":"Hammerhead.PeakRatioValidator","text":"PeakRatioValidator(threshold::Float64)\n\nValidates vectors based on correlation peak ratio (primary/secondary peak). Higher ratios indicate more reliable correlations.\n\nArguments\n\nthreshold: Minimum acceptable peak ratio (typically 1.1-1.5)\n\nExample\n\nvalidator = PeakRatioValidator(1.2)  # Require peak ratio ≥ 1.2\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.VectorMedian","page":"Internals","title":"Hammerhead.VectorMedian","text":"VectorMedian <: AbstractReplacementMethod\n\nFast median-based replacement for isolated (1×1) holes.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Hammerhead.VelocityMagnitudeValidator","page":"Internals","title":"Hammerhead.VelocityMagnitudeValidator","text":"VelocityMagnitudeValidator(min::Float64, max::Float64)\n\nValidates vectors based on displacement magnitude bounds. Filters out physically unrealistic displacements.\n\nArguments\n\nmin: Minimum acceptable displacement magnitude\nmax: Maximum acceptable displacement magnitude\n\nExample\n\nvalidator = VelocityMagnitudeValidator(0.1, 50.0)  # Magnitude between 0.1-50 pixels\n\n\n\n\n\n","category":"type"},{"location":"internals/#Synthetic-Data","page":"Internals","title":"Synthetic Data","text":"","category":"section"},{"location":"internals/#Hammerhead.SyntheticData.displace_particles","page":"Internals","title":"Hammerhead.SyntheticData.displace_particles","text":"displace_particles(particles::ParticleField3D, velocity_function, dt::Real, t::Real=0.0) -> ParticleField3D\n\nCreate a new ParticleField3D with particles displaced according to the velocity function.\n\nArguments\n\nparticles: ParticleField3D to displace\nvelocity_function: Function with signature (x, y, z, t) -> (u, v, w)\ndt: Time step\nt: Current time (default 0.0)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Hammerhead.SyntheticData.laser_intensity-Tuple{Hammerhead.SyntheticData.GaussianLaserSheet, Real}","page":"Internals","title":"Hammerhead.SyntheticData.laser_intensity","text":"laser_intensity(laser::LaserSheet, z) -> intensity_multiplier\n\nCalculate the laser intensity multiplier at z-position.\n\n\n\n\n\n","category":"method"}]
}
